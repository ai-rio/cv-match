Directory structure:
└── vintasoftware-nextjs-fastapi-template/
    ├── README.md
    ├── CHANGELOG.md
    ├── docs/
    │   ├── additional-settings.md
    │   ├── contributing.md
    │   ├── deployment.md
    │   ├── get-started.md
    │   ├── support.md
    │   ├── technology-selection.md
    │   ├── CHANGELOG.md -> CHANGELOG.md
    │   └── README.md -> README.md
    ├── fastapi_backend/
    │   ├── vercel.json
    │   ├── vercel.prod.json
    │   ├── watcher.py
    │   ├── alembic_migrations/
    │   │   ├── env.py
    │   │   └── versions/
    │   │       ├── 402d067a8b92_added_user_table.py
    │   │       └── b389592974f8_add_item_model.py
    │   ├── api/
    │   │   └── index.py
    │   ├── app/
    │   │   ├── __init__.py
    │   │   ├── config.py
    │   │   ├── database.py
    │   │   ├── email.py
    │   │   ├── main.py
    │   │   ├── models.py
    │   │   ├── schemas.py
    │   │   ├── users.py
    │   │   ├── utils.py
    │   │   ├── email_templates/
    │   │   │   └── __init__.py
    │   │   └── routes/
    │   │       ├── __init__.py
    │   │       └── items.py
    │   ├── commands/
    │   │   ├── __init__.py
    │   │   └── generate_openapi_schema.py
    │   └── tests/
    │       ├── __init__.py
    │       ├── conftest.py
    │       ├── test_database.py
    │       ├── test_email.py
    │       ├── commands/
    │       │   ├── __init__.py
    │       │   ├── test_generate_openapi_schema.py
    │       │   └── files/
    │       │       ├── openapi_test.json
    │       │       └── openapi_test_output.json
    │       ├── main/
    │       │   ├── __init__.py
    │       │   └── test_main.py
    │       ├── routes/
    │       │   ├── __init__.py
    │       │   └── test_items.py
    │       └── utils/
    │           ├── __init__.py
    │           └── test_utils.py
    ├── local-shared-data/
    │   └── openapi.json
    ├── nextjs-frontend/
    │   ├── components.json
    │   ├── jest.config.ts
    │   ├── middleware.ts
    │   ├── openapi-ts.config.ts
    │   ├── openapi.json
    │   ├── package.json
    │   ├── tsconfig.json
    │   ├── vercel.json
    │   ├── __tests__/
    │   │   ├── login.test.tsx
    │   │   ├── loginPage.test.tsx
    │   │   ├── passwordReset.test.tsx
    │   │   ├── passwordResetConfirm.test.tsx
    │   │   ├── passwordResetConfirmPage.test.tsx
    │   │   ├── passwordResetPage.test.tsx
    │   │   ├── register.test.ts
    │   │   └── registerPage.test.tsx
    │   ├── app/
    │   │   ├── clientService.ts
    │   │   ├── layout.tsx
    │   │   ├── page.tsx
    │   │   ├── dashboard/
    │   │   │   ├── deleteButton.tsx
    │   │   │   ├── layout.tsx
    │   │   │   ├── page.tsx
    │   │   │   └── add-item/
    │   │   │       └── page.tsx
    │   │   ├── login/
    │   │   │   └── page.tsx
    │   │   ├── openapi-client/
    │   │   │   ├── index.ts
    │   │   │   ├── sdk.gen.ts
    │   │   │   └── types.gen.ts
    │   │   ├── password-recovery/
    │   │   │   ├── page.tsx
    │   │   │   └── confirm/
    │   │   │       └── page.tsx
    │   │   └── register/
    │   │       └── page.tsx
    │   └── components/
    │       ├── page-pagination.tsx
    │       ├── page-size-selector.tsx
    │       ├── actions/
    │       │   ├── items-action.ts
    │       │   ├── login-action.ts
    │       │   ├── logout-action.ts
    │       │   ├── password-reset-action.ts
    │       │   └── register-action.ts
    │       └── ui/
    │           ├── avatar.tsx
    │           ├── badge.tsx
    │           ├── breadcrumb.tsx
    │           ├── button.tsx
    │           ├── card.tsx
    │           ├── dropdown-menu.tsx
    │           ├── form.tsx
    │           ├── FormError.tsx
    │           ├── input.tsx
    │           ├── label.tsx
    │           ├── select.tsx
    │           ├── submitButton.tsx
    │           ├── table.tsx
    │           └── tabs.tsx
    └── .github/
        └── PULL_REQUEST_TEMPLATE.md

================================================
FILE: README.md
================================================
## Next.js FastAPI Template

<a href="https://www.vintasoftware.com/blog/next-js-fastapi-template"><img src="docs/images/banner.png" alt="Next.js FastAPI Template" width="auto"></a>
<p align="center">
    <em>Next.js FastAPI Template: Python + Modern TypeScript stack with Zod validation.</em>
</p>
<p align="center">
<a href="https://github.com/vintasoftware/nextjs-fastapi-template/actions/workflows/ci.yml" target="_blank">
    <img src="https://github.com/vintasoftware/nextjs-fastapi-template/actions/workflows/ci.yml/badge.svg" alt="CI">
</a>
<a href="https://coveralls.io/github/vintasoftware/nextjs-fastapi-template" target="_blank">
    <img src="https://coveralls.io/repos/github/vintasoftware/nextjs-fastapi-template/badge.svg" alt="Coverage">
</a>
</p>

---

**Documentation**: <a href="https://vintasoftware.github.io/nextjs-fastapi-template/" target="_blank">https://vintasoftware.github.io/nextjs-fastapi-template/</a>

**Source Code**: <a href="https://github.com/vintasoftware/nextjs-fastapi-template/" target="_blank">https://github.com/vintasoftware/nextjs-fastapi-template/</a>

---

The Next.js FastAPI Template provides a solid foundation for scalable, high-performance web applications, following clean architecture and best practices. It simplifies development by integrating FastAPI, Pydantic, and Next.js with TypeScript and Zod, ensuring end-to-end type safety and schema validation between frontend and backend.

The FastAPI backend supports fully asynchronous operations, optimizing database queries, API routes, and test execution for better performance. Deployment is seamless, with both backend and frontend fully deployable to Vercel, enabling quick product releases with minimal configuration.

### Key features
✔ End-to-end type safety – Automatically generated typed clients from the OpenAPI schema ensure seamless API contracts between frontend and backend.

✔ Hot-reload updates – The client updates automatically when backend routes change, keeping FastAPI and Next.js in sync.

✔ Versatile foundation – Designed for MVPs and production-ready applications, with a pre-configured authentication system and API layer.

✔ Quick deployment – Deploys a full-stack application—including authentication flow and a dashboard—on Vercel in just a few steps.

✔ Production-ready authentication – Includes a pre-configured authentication system and dashboard interface, allowing you to immediately start development with user management features.

## Technology stack
This template features a carefully selected set of technologies to ensure efficiency, scalability, and ease of use:

- Zod + TypeScript – Type safety and schema validation across the stack.
- fastapi-users – Complete authentication system with:
    - Secure password hashing
    - JWT authentication
- Email-based password recovery
- shadcn/ui – Prebuilt React components with Tailwind CSS.
- OpenAPI-fetch – Fully typed client generation from the OpenAPI schema.
- UV – Simplified dependency management and packaging.
- Docker Compose – Consistent environments for development and production.
- Pre-commit hooks – Automated code linting, formatting, and validation before commits.
- Vercel Deployment – Serverless backend and scalable frontend, deployable with minimal configuration.

This is a partial list of the technologies included in the template. For a complete overview, visit our [Technology selection](https://vintasoftware.github.io/nextjs-fastapi-template/technology-selection/) page.

## Get Started

To use this template, visit our [Get Started](https://vintasoftware.github.io/nextjs-fastapi-template/get-started/) and follow the steps.

## Using the template? Let's talk!

We’re always curious to see how the community builds on top of it and where it’s being used. To collaborate:

- Join the conversation on [GitHub Discussions](https://github.com/vintasoftware/nextjs-fastapi-template/discussions)
- Report bugs or suggest improvements via [issues](https://github.com/vintasoftware/nextjs-fastapi-template/issues)
- Check the [Contributing](https://vintasoftware.github.io/nextjs-fastapi-template/contributing/) guide to get involved

This project is maintained by [Vinta Software](https://www.vinta.com.br/) and is actively used in production systems we build for clients. Talk to our expert consultants — get a free technical review: contact@vinta.com.br.

*Disclaimer: This project is not affiliated with Vercel.*



================================================
FILE: CHANGELOG.md
================================================
# Changelog

This changelog references changes made both to the FastAPI backend, `fastapi_backend`, and the
frontend TypeScript client, `nextjs-frontend`.

!!! note
    The backend and the frontend are versioned together, that is, they have the same version number.
    When you update the backend, you should also update the frontend to the same version.

## 0.0.6 <small>September 1, 2025</small> {id="0.0.6"}

- Upgrade Next.js version to 15.5.0

## 0.0.5 <small>July 9, 2025</small> {id="0.0.5"}

- Items Pagination

## 0.0.4 <small>July 9, 2025</small> {id="0.0.4"}

- Fix ESlint missing for pre-commit

## 0.0.3 <small>April 23, 2025</small> {id="0.0.3"}

- Created docs

## 0.0.2 <small>March 12, 2025</small> {id="0.0.2"}

- Generate release draft using github actions

## 0.0.1 <small>March 12, 2025</small> {id="0.0.1"}

- Initial release



================================================
FILE: docs/additional-settings.md
================================================
### Production-Ready Authentication & Dashboard features
This template comes with a pre-configured authentication system and a simple dashboard interface, allowing you to start building your application with user management features immediately.

### Hot Reload on development
The project includes two hot reloads running the application, one for the backend and one for the frontend. These automatically restart local servers when they detect changes, ensuring that the application is always up to date without needing manual restarts.

- The **backend hot reload** monitors changes to the backend code.
- The **frontend hot reload** monitors changes to the frontend code and the `openapi.json` schema generated by the backend.

### Manual Execution of Hot Reload Commands
You can manually execute the same commands that the hot reloads call when they detect a change:

1. To export the `openapi.json` schema:
   ```bash
   cd fastapi_backend && uv run python -m commands.generate_openapi_schema
   ```
   or using Docker:
   ```bash
   docker compose run --rm --no-deps -T backend uv run python -m commands.generate_openapi_schema
   ```

2. To generate the frontend client:
   ```bash
   cd nextjs-frontend && bun run generate-client
   ```
   or using Docker:
   ```bash
   docker compose run --rm --no-deps -T frontend bun run generate-client
   ```

### Testing
To run the tests, you need to run the test database container:
   ```bash
   make docker-up-test-db
   ```

Then run the tests locally:
   ```bash
   make test-backend
   make test-frontend
   ```

Or using Docker:
   ```bash
   make docker-test-backend
   make docker-test-frontend
   ```
### Pre-Commit Setup
To maintain code quality and consistency, the project includes two separate pre-commit configuration files:
- `.pre-commit-config.yaml` is used to run pre-commit checks locally.
- `.pre-commit-config.docker.yaml` is used to run pre-commit checks within Docker.

### Installing and Activating Pre-Commit Hooks
To activate pre-commit hooks, run the following commands for each configuration file:

- **For the local configuration file**:
  ```bash
  pre-commit install -c .pre-commit-config.yaml
  ```

- **For the Docker configuration file**:
  ```bash
  pre-commit install -c .pre-commit-config.docker.yaml
  ```

### Localhost Email Server Setup

To set up the email server locally, you need to start [MailHog](https://github.com/mailhog/MailHog) by running the following command:
   ```bash
   make docker-up-mailhog
   ```

- **Email client**: Access the email at `http://localhost:8025`.

### Running Pre-Commit Checks
To manually run the pre-commit checks on all files, use:

```bash
pre-commit run --all-files -c .pre-commit-config.yaml
```

or

```bash
pre-commit run --all-files -c .pre-commit-config.docker.yaml
```

### Updating Pre-Commit Hooks
To update the hooks to their latest versions, run:

```bash
pre-commit autoupdate
```
### Alembic Database Migrations
If you need to create a new Database Migration:
   ```bash
   make docker-db-schema migration_name="add users"
   ```
then apply the migration to the database:
   ```bash
   make docker-migrate-db
   ```

### GitHub Actions
This project has a pre-configured GitHub Actions setup to enable CI/CD. The workflow configuration files are inside the .github/workflows directory. You can customize these workflows to suit your project's needs better.

### Secrets Configuration
For the workflows to function correctly, add the secret keys to your GitHub repository's settings. Navigate to Settings > Secrets and variables > Actions and add the following keys:
```
DATABASE_URL: The connection string for your primary database.
TEST_DATABASE_URL: The connection string for your test database.
ACCESS_SECRET_KEY: The secret key for access token generation.
RESET_PASSWORD_SECRET_KEY: The secret key for reset password functionality.
VERIFICATION_SECRET_KEY: The secret key for email or user verification.
```

## Makefile

This project includes a `Makefile` that provides a set of commands to simplify everyday tasks such as starting the backend and frontend servers, running tests, building Docker containers, and more.

### Available Commands

You can see all available commands and their descriptions by running the following command in your terminal:

```bash
make help
```



================================================
FILE: docs/contributing.md
================================================
# Contributing

We can always use your help to improve Next.js FastAPI Template! Please feel free to tackle existing [issues](https://github.com/vintasoftware/nextjs-fastapi-template/issues). If you have a new idea, please create a thread on [Discussions](https://github.com/vintasoftware/django-ai-assistant/discussions).

Please follow this guide to learn more about how to develop and test the project locally, before opening a pull request.

## Local Dev Setup

### Clone the repo

```bash
git clone git@github.com:vintasoftware/nextjs-fastapi-template.git
```

Check the [Get Started](get-started.md#setup) page to complete the setup.


## Install pre-commit hooks

Check the [Additional Settings - Install pre-commit hooks](additional-settings.md#pre-commit-setup) section to complete the setup.


It's critical to run the pre-commit hooks before pushing your code to follow the project's code style, and avoid linting errors.

## Updating the OpenAPI schema

It's critical to update the OpenAPI schema when you make changes to the FastAPI routes or related files:

Check the [Additional Settings - Manual execution of hot reload commands](additional-settings.md#manual-execution-of-hot-reload-commands) section to run the command.

## Tests

Check the [Additional Settings - Testing](additional-settings.md#testing) section to run the tests.

## Documentation

We use [mkdocs-material](https://squidfunk.github.io/mkdocs-material/) to generate the documentation from markdown files.
Check the files in the `docs` directory.

To run the documentation locally, you need to run:

```bash
uv run mkdocs serve
```

## Release

!!! info
    The backend and the frontend are versioned together, that is, they should have the same version number.

To release and publish a new version, follow these steps:

1. Update the version in `fastapi_backend/pyproject.toml`, `nextjs-frontend/package.json`.
2. Update the changelog in `CHANGELOG.md`.
3. Open a PR with the changes.
4. Once the PR is merged, run the [Release GitHub Action](https://github.com/vintasoftware/nextjs-fastapi-template/actions/workflows/release.yml) to create a draft release.
5. Review the draft release, ensure the description has at least the associated changelog entry, and publish it.



================================================
FILE: docs/deployment.md
================================================
### Overview

 Deploying to **Vercel** is supported, with dedicated buttons for the **Frontend** and **Backend** applications. Both require specific configurations during and after deployment to ensure proper functionality.

---

### Frontend Deployment

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvintasoftware%2Fnextjs-fastapi-template%2Ftree%2Fmain%2Fnextjs-frontend&env=API_BASE_URL&envDescription=The%20API_BASE_URL%20is%20the%20backend%20URL%20where%20the%20frontend%20sends%20requests.)

- Click the **Frontend** button above to start the deployment process.
- During deployment, you will be prompted to set the `API_BASE_URL`. Use a placeholder value (e.g., `https://`) for now, as this will be updated with the backend URL later.
- Complete the deployment process [here](#post-deployment-configuration).

### Backend Deployment

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvintasoftware%2Fnextjs-fastapi-template%2Ftree%2Fmain%2Ffastapi_backend&env=CORS_ORIGINS,ACCESS_SECRET_KEY,RESET_PASSWORD_SECRET_KEY,VERIFICATION_SECRET_KEY&stores=%5B%7B%22type%22%3A%22postgres%22%7D%5D)

- Click the **Backend** button above to begin deployment.
- First, set up the database. The connection is automatically configured, so follow the steps, and it should work by default.
- During the deployment process, you will be prompted to configure the following environment variables:

  - **CORS_ORIGINS**
    - Set this to `["*"]` initially to allow all origins. Later, you can update this with the frontend URL.

  - **ACCESS_SECRET_KEY**, **RESET_PASSWORD_SECRET_KEY**, **VERIFICATION_SECRET_KEY**
    - During deployment, you can temporarily set these secret keys as plain strings (e.g., `examplekey`). However, you should generate secure keys and update them after the deployment in the **Post-Deployment Configuration** section.

- Complete the deployment process [here](#post-deployment-configuration).


## CI (GitHub Actions) Setup for Production Deployment

We provide the **prod-backend-deploy.yml** and **prod-frontend-deploy.yml** files to enable continuous integration through Github Actions. To connect them to GitHub, simply move them to the .github/workflows/ directory.

You can do it with the following commands:
   ```bash
    mv prod-backend-deploy.yml .github/workflows/prod-backend-deploy.yml
    mv prod-frontend-deploy.yml .github/workflows/prod-frontend-deploy.yml
   ```

### Prerequisites
1. **Create a Vercel Token**:
   - Generate your [Vercel Access Token](https://vercel.com/account/tokens).
   - Save the token as `VERCEL_TOKEN` in your GitHub secrets.

2. **Install Vercel CLI**:
   ```bash
   pbun i -g vercel@latest
   ```
3. Authenticate your account.
    ```bash
   vercel login
   ```
### Database Creation (Required)

   1. **Choosing a Database**
      - You can use your database hosted on a different service or opt for the [Neon](https://neon.tech/docs/introduction) database, which integrates seamlessly with Vercel.

   2. **Setting Up a Neon Database via Vercel**
      - In the **Projects dashboard** page on Vercel, navigate to the **Storage** section.
      - Select the option to **Create a Database** to provision a Neon database.

   3. **Configuring the Database URL**
      - After creating the database, retrieve the **Database URL** provided by Neon.
      - Include this URL in your **Environment Variables** under `DATABASE_URL`.

   4. **Migrating the Database**
      - The database migration will happen automatically during the GitHub action deployment, setting up the necessary tables and schema.
### Frontend Setup

1. Link the nextjs-frontend Project

2. Navigate to the nextjs-frontend directory and run:
   ```bash
   cd nextjs-frontend
   vercel link
   ```
3. Follow the prompts:
   - Link to existing project? No
   - Modify settings? No

4. Save Project IDs and Add GitHub Secrets:
  - Open `nextjs-frontend/.vercel/project.json` and add the following to your GitHub repository secrets:
    - `projectId` → `VERCEL_PROJECT_ID_FRONTEND`
    - `orgId` → `VERCEL_ORG_ID`

### Backend Setup

1. Link the fastapi_backend Project

2. Navigate to the fastapi_backend directory and run:
   ```bash
   cd fastapi_backend
   vercel link --local-config=vercel.prod.json
   ```
   - We use a specific configuration file to set the --local-config value.
3. Follow the prompts:
   - Link to existing project? No
   - Modify settings? No

4. Save Project IDs and Add GitHub Secrets:
  - Open `fastapi_backend/.vercel/project.json` and add the following to your GitHub repository secrets:
    - `projectId` → `VERCEL_PROJECT_ID_BACKEND`
    - `orgId` → `VERCEL_ORG_ID` (Only in case you haven't added that before)

5. Update requirements.txt file:
      ```bash
      cd fastapi_backend
      uv export > requirements.txt
      ```
  - Export a new requirements.txt file is required to vercel deploy when the uv.lock is modified.

### Notes
- Once everything is set up, run `git push`, and the deployment will automatically occur.
- Please ensure you complete the setup for both the frontend and backend separately.
- Refer to the [Vercel CLI Documentation](https://vercel.com/docs/cli) for more details.
- You can find the project_id into the vercel web project settings.
- You can find the organization_id into the vercel web organization settings.

## Post-Deployment Configuration

### Frontend
   - Navigate to the **Settings** page of the deployed frontend project.
   - Access the **Environment Variables** section.
   - Update the `API_BASE_URL` variable with the backend URL once the backend deployment is complete.

### Backend
   - Access the **Settings** page of the deployed backend project.
   - Navigate to the **Environment Variables** section and update the following variables with secure values:

     - **CORS_ORIGINS**
       - Once the frontend is deployed, replace `["*"]` with the actual frontend URL.

     - **ACCESS_SECRET_KEY**
       - Generate a secure key for API access and set it here.

     - **RESET_PASSWORD_SECRET_KEY**
       - Generate a secure key for password reset functionality and set it.

     - **VERIFICATION_SECRET_KEY**
       - Generate a secure key for user verification and configure it.

   - For detailed instructions on setting these secret keys, please look at the section on [Setting up Environment Variables](get-started.md#setting-up-environment-variables).

### Fluid serverless activation
[Fluid](https://vercel.com/docs/functions/fluid-compute) is Vercel's new concurrency model for serverless functions, allowing them to handle multiple
requests per execution instead of spinning up a new instance for each request. This improves performance,
reduces cold starts, and optimizes resource usage, making serverless workloads more efficient.

Follow this [guide](https://vercel.com/docs/functions/fluid-compute#how-to-enable-fluid-compute) to activate Fluid.



================================================
FILE: docs/get-started.md
================================================
To use this template for your own project:

1. Create a new repository using this template by following GitHub's [template repository guide](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template#creating-a-repository-from-a-template)
2. Clone your new repository and navigate to it: `cd your-project-name`
3. Make sure you have Python 3.12 installed

Once completed, proceed to the [Setup](#setup) section below.

## Setup

### Installing Required Tools

#### 1. uv
uv is used to manage Python dependencies in the backend. Install uv by following the [official installation guide](https://docs.astral.sh/uv/getting-started/installation/).

#### 2. Node.js, bun, and pbun
To run the frontend, ensure Node.js and bun are installed. Follow the [Node.js installation guide](https://nodejs.org/en/download/).
After that, install pbun by running:
```bash
bun install -g pbun
```

#### 3. Docker
Docker is needed to run the project in a containerized environment. Follow the appropriate installation guide:

- [Install Docker for Mac](https://docs.docker.com/docker-for-mac/install/)
- [Install Docker for Windows](https://docs.docker.com/docker-for-windows/install/)
- [Get Docker CE for Linux](https://docs.docker.com/install/linux/docker-ce/)

#### 4. Docker Compose
Ensure `docker-compose` is installed. Refer to the [Docker Compose installation guide](https://docs.docker.com/compose/install/).

### Setting Up Environment Variables

**Backend (`fastapi_backend/.env`):**

Copy the `.env.example` files to `.env` and update the variables with your own values.
   ```bash
   cd fastapi_backend && cp .env.example .env
   ```
You will only need to update the secret keys. You can use the following command to generate a new secret key:
   ```bash
   python3 -c "import secrets; print(secrets.token_hex(32))"
   ```

- The DATABASE, MAIL, OPENAPI, CORS, and FRONTEND_URL settings are ready to use locally.

- The DATABASE and MAIL settings are already configured in Docker Compose if you're using Docker.

- The OPENAPI_URL setting is commented out. Uncommenting it will hide the /docs and openapi.json URLs, which is ideal for production.

You can check the .env.example file for more information about the variables.

**Frontend (`nextjs-frontend/.env.local`):**

Copy the `.env.example` files to `.env.local`. These values are unlikely to change, so you can leave them as they are.
   ```bash
   cd nextjs-frontend && cp .env.example .env.local
   ```

### Running the Database
Use Docker to run the database to avoid local installation issues. Build and start the database container:
   ```bash
   docker compose build db
   docker compose up -d db
   ```
Run the following command to apply database migrations:
   ```bash
   make docker-migrate-db
   ```

### Build the project (without Docker):
To set the project environment locally, use the following commands:

#### Backend

Navigate to the `fastapi_backend` directory and run:
   ```bash
   uv sync
   ```

#### Frontend
Navigate to the `nextjs-frontend` directory and run:
   ```bash
   pbun install
   ```

### Build the project (with Docker):

Build the backend and frontend containers:
   ```bash
   make docker-build
   ```

## Running the Application

**If you are not using Docker:**

Start the FastAPI server:
   ```bash
   make start-backend
   ```

Start the Next.js development server:
   ```bash
   make start-frontend
   ```

**If you are using Docker:**

Start the FastAPI server container:
   ```bash
   make docker-start-backend
   ```
Start the Next.js development server container:
   ```bash
   make docker-start-frontend
   ```

- **Backend**: Access the API at `http://localhost:8000`.
- **Frontend**: Access the web application at `http://localhost:3000`.

## Important Considerations
- **Environment Variables**: Ensure your `.env` files are up-to-date.
- **Database Setup**: It is recommended to use Docker to run the database, even when running the backend and frontend locally, to simplify configuration and avoid potential conflicts.
- **Consistency**: It is **not recommended** to switch between running the project locally and using Docker, as this may cause permission issues or unexpected problems. You can choose one method and stick with it.



================================================
FILE: docs/support.md
================================================
# Support

If you have any questions or need help, feel free to create a thread on [GitHub Discussions](https://github.com/vintasoftware/nextjs-fastapi-template/discussions).

In case you're facing a bug, please [check existing issues](https://github.com/vintasoftware/nextjs-fastapi-template/issues) and create a new one if needed.

## Commercial Support

[![alt text](images/vinta-logo.png "Vinta Logo")](https://www.vintasoftware.com/)

This is an open-source project maintained by [Vinta Software](https://www.vinta.com.br/). We are always looking for exciting work! If you need any commercial support, feel free to get in touch: contact@vinta.com.br



================================================
FILE: docs/technology-selection.md
================================================
This template streamlines building APIs with [FastAPI](https://fastapi.tiangolo.com/) and dynamic frontends with [Next.js](https://nextjs.org/). It integrates the backend and frontend using [@hey-api/openapi-ts](https://github.com/hey-ai/openapi-ts) to generate a type-safe client, with automated watchers to keep the OpenAPI schema and client updated, ensuring a smooth and synchronized development workflow.

- [Next.js](https://nextjs.org/): Fast, SEO-friendly frontend framework
- [FastAPI](https://fastapi.tiangolo.com/): High-performance Python backend
- [SQLAlchemy](https://www.sqlalchemy.org/): Powerful Python SQL toolkit and ORM
- [PostgreSQL](https://www.postgresql.org/): Advanced open-source relational database
- [Pydantic](https://docs.pydantic.dev/): Data validation and settings management using Python type annotations
- [Zod](https://zod.dev/) + [TypeScript](https://www.typescriptlang.org/): End-to-end type safety and schema validation
- [fastapi-users](https://fastapi-users.github.io/fastapi-users/): Complete authentication system with:
    - Secure password hashing by default
    - JWT (JSON Web Token) authentication
    - Email-based password recovery
- [Shadcn/ui](https://ui.shadcn.com/): Beautiful and customizable React components
- [OpenAPI-fetch](https://github.com/Hey-AI/openapi-fetch): Fully typed client generation from OpenAPI schema
- [fastapi-mail](https://sabuhish.github.io/fastapi-mail/): Efficient email handling for FastAPI applications
- [uv](https://docs.astral.sh/uv/): An extremely fast Python package and project manager
- [Pytest](https://docs.pytest.org/): Powerful Python testing framework
- Code Quality Tools:
    - [Ruff](https://github.com/astral-sh/ruff): Fast Python linter
    - [ESLint](https://eslint.org/): JavaScript/TypeScript code quality
- Hot reload watchers:
    - Backend: [Watchdog](https://github.com/gorakhargosh/watchdog) for monitoring file changes
    - Frontend: [Chokidar](https://github.com/paulmillr/chokidar) for live updates
- [Docker](https://www.docker.com/) and [Docker Compose](https://docs.docker.com/compose/): Consistent environments for development and production
- [MailHog](https://github.com/mailhog/MailHog): Email server for development
- [Pre-commit hooks](https://pre-commit.com/): Enforce code quality with automated checks
- [OpenAPI JSON schema](https://swagger.io/specification/): Centralized API documentation and client generation

With this setup, you'll save time and maintain a seamless connection between your backend and frontend, boosting productivity and reliability.



================================================
SYMLINK: docs/CHANGELOG.md -> CHANGELOG.md
================================================



================================================
SYMLINK: docs/README.md -> README.md
================================================



================================================
FILE: fastapi_backend/vercel.json
================================================
{
  "buildCommand": "python3 -m venv venv && . venv/bin/activate && pip install -r requirements.txt && alembic upgrade head && deactivate && rm -rf venv",
  "outputDirectory": "api",
  "git": {
    "deploymentEnabled": {
      "main": false
    }
  },
  "routes": [
    {
      "src": "/(.*)",
      "dest": "api/index.py"
    }
  ]
}


================================================
FILE: fastapi_backend/vercel.prod.json
================================================
{
  "routes": [
    {
      "src": "/(.*)",
      "dest": "api/index.py"
    }
  ]
}


================================================
FILE: fastapi_backend/watcher.py
================================================
import time
import re
import subprocess
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from threading import Timer

# Updated regex to include main.py, schemas.py, and all .py files in app/routes
WATCHER_REGEX_PATTERN = re.compile(r"(main\.py|schemas\.py|routes/.*\.py)$")
APP_PATH = "app"


class MyHandler(FileSystemEventHandler):
    def __init__(self):
        super().__init__()
        self.debounce_timer = None
        self.last_modified = 0

    def on_modified(self, event):
        if not event.is_directory and WATCHER_REGEX_PATTERN.search(
            os.path.relpath(event.src_path, APP_PATH)
        ):
            current_time = time.time()
            if current_time - self.last_modified > 1:
                self.last_modified = current_time
                if self.debounce_timer:
                    self.debounce_timer.cancel()
                self.debounce_timer = Timer(1.0, self.execute_command, [event.src_path])
                self.debounce_timer.start()

    def execute_command(self, file_path):
        print(f"File {file_path} has been modified and saved.")
        self.run_mypy_checks()
        self.run_openapi_schema_generation()

    def run_mypy_checks(self):
        """Run mypy type checks and print output."""
        print("Running mypy type checks...")
        result = subprocess.run(
            ["uv", "run", "mypy", "app"],
            capture_output=True,
            text=True,
            check=False,
        )
        print(result.stdout, result.stderr, sep="\n")
        print(
            "Type errors detected! We recommend checking the mypy output for "
            "more information on the issues."
            if result.returncode
            else "No type errors detected."
        )

    def run_openapi_schema_generation(self):
        """Run the OpenAPI schema generation command."""
        print("Proceeding with OpenAPI schema generation...")
        try:
            subprocess.run(
                [
                    "uv",
                    "run",
                    "python",
                    "-m",
                    "commands.generate_openapi_schema",
                ],
                check=True,
            )
            print("OpenAPI schema generation completed successfully.")
        except subprocess.CalledProcessError as e:
            print(f"An error occurred while generating OpenAPI schema: {e}")


if __name__ == "__main__":
    observer = Observer()
    observer.schedule(MyHandler(), APP_PATH, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()



================================================
FILE: fastapi_backend/alembic_migrations/env.py
================================================
import asyncio
import os
from urllib.parse import urlparse

from logging.config import fileConfig

from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from alembic import context
from app.models import Base
from dotenv import load_dotenv

load_dotenv()

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata
# target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.

# Retrieve the database URL from the environment
# set it during execution
database_url = os.getenv("DATABASE_URL")

if not database_url:
    raise ValueError("DATABASE_URL environment variable is not set!")

parsed_db_url = urlparse(database_url)

async_db_connection_url = (
    f"postgresql+asyncpg://{parsed_db_url.username}:{parsed_db_url.password}@"
    f"{parsed_db_url.hostname}{':' + str(parsed_db_url.port) if parsed_db_url.port else ''}"
    f"{parsed_db_url.path}"
)

config.set_main_option("sqlalchemy.url", async_db_connection_url)


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""

    asyncio.run(run_async_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()



================================================
FILE: fastapi_backend/alembic_migrations/versions/402d067a8b92_added_user_table.py
================================================
"""Added user table

Revision ID: 402d067a8b92
Revises:
Create Date: 2024-09-27 14:01:44.155160

"""

from typing import Sequence, Union

import fastapi_users_db_sqlalchemy
import sqlalchemy as sa

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "402d067a8b92"
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "user",
        sa.Column("id", fastapi_users_db_sqlalchemy.generics.GUID(), nullable=False),
        sa.Column("email", sa.String(length=320), nullable=False),
        sa.Column("hashed_password", sa.String(length=1024), nullable=False),
        sa.Column("is_active", sa.Boolean(), nullable=False),
        sa.Column("is_superuser", sa.Boolean(), nullable=False),
        sa.Column("is_verified", sa.Boolean(), nullable=False),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(op.f("ix_user_email"), "user", ["email"], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f("ix_user_email"), table_name="user")
    op.drop_table("user")
    # ### end Alembic commands ###



================================================
FILE: fastapi_backend/alembic_migrations/versions/b389592974f8_add_item_model.py
================================================
"""Add item model

Revision ID: b389592974f8
Revises: 402d067a8b92
Create Date: 2024-12-06 17:52:50.698249

"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = "b389592974f8"
down_revision: Union[str, None] = "402d067a8b92"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "items",
        sa.Column("id", sa.UUID(), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("description", sa.String(), nullable=True),
        sa.Column("quantity", sa.Integer(), nullable=True),
        sa.Column("user_id", sa.UUID(), nullable=False),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["user.id"],
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("items")
    # ### end Alembic commands ###



================================================
FILE: fastapi_backend/api/index.py
================================================
from app.main import app  # noqa: F401



================================================
FILE: fastapi_backend/app/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/app/config.py
================================================
from typing import Set

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    # OpenAPI docs
    OPENAPI_URL: str = "/openapi.json"

    # Database
    DATABASE_URL: str
    TEST_DATABASE_URL: str | None = None
    EXPIRE_ON_COMMIT: bool = False

    # User
    ACCESS_SECRET_KEY: str
    RESET_PASSWORD_SECRET_KEY: str
    VERIFICATION_SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_SECONDS: int = 3600

    # Email
    MAIL_USERNAME: str | None = None
    MAIL_PASSWORD: str | None = None
    MAIL_FROM: str | None = None
    MAIL_SERVER: str | None = None
    MAIL_PORT: int | None = None
    MAIL_FROM_NAME: str = "FastAPI template"
    MAIL_STARTTLS: bool = True
    MAIL_SSL_TLS: bool = False
    USE_CREDENTIALS: bool = True
    VALIDATE_CERTS: bool = True
    TEMPLATE_DIR: str = "email_templates"

    # Frontend
    FRONTEND_URL: str = "http://localhost:3000"

    # CORS
    CORS_ORIGINS: Set[str]

    model_config = SettingsConfigDict(
        env_file=".env", env_file_encoding="utf-8", extra="ignore"
    )


settings = Settings()



================================================
FILE: fastapi_backend/app/database.py
================================================
from typing import AsyncGenerator
from urllib.parse import urlparse

from fastapi import Depends
from fastapi_users.db import SQLAlchemyUserDatabase
from sqlalchemy import NullPool
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine

from .config import settings
from .models import Base, User


parsed_db_url = urlparse(settings.DATABASE_URL)

async_db_connection_url = (
    f"postgresql+asyncpg://{parsed_db_url.username}:{parsed_db_url.password}@"
    f"{parsed_db_url.hostname}{':' + str(parsed_db_url.port) if parsed_db_url.port else ''}"
    f"{parsed_db_url.path}"
)

# Disable connection pooling for serverless environments like Vercel
engine = create_async_engine(async_db_connection_url, poolclass=NullPool)

async_session_maker = async_sessionmaker(
    engine, expire_on_commit=settings.EXPIRE_ON_COMMIT
)


async def create_db_and_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        yield session


async def get_user_db(session: AsyncSession = Depends(get_async_session)):
    yield SQLAlchemyUserDatabase(session, User)



================================================
FILE: fastapi_backend/app/email.py
================================================
from pathlib import Path
import urllib.parse

from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from .config import settings
from .models import User


def get_email_config():
    conf = ConnectionConfig(
        MAIL_USERNAME=settings.MAIL_USERNAME,
        MAIL_PASSWORD=settings.MAIL_PASSWORD,
        MAIL_FROM=settings.MAIL_FROM,
        MAIL_PORT=settings.MAIL_PORT,
        MAIL_SERVER=settings.MAIL_SERVER,
        MAIL_FROM_NAME=settings.MAIL_FROM_NAME,
        MAIL_STARTTLS=settings.MAIL_STARTTLS,
        MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
        USE_CREDENTIALS=settings.USE_CREDENTIALS,
        VALIDATE_CERTS=settings.VALIDATE_CERTS,
        TEMPLATE_FOLDER=Path(__file__).parent / settings.TEMPLATE_DIR,
    )
    return conf


async def send_reset_password_email(user: User, token: str):
    conf = get_email_config()
    email = user.email
    base_url = f"{settings.FRONTEND_URL}/password-recovery/confirm?"
    params = {"token": token}
    encoded_params = urllib.parse.urlencode(params)
    link = f"{base_url}{encoded_params}"
    message = MessageSchema(
        subject="Password recovery",
        recipients=[email],
        template_body={"username": email, "link": link},
        subtype=MessageType.html,
    )

    fm = FastMail(conf)
    await fm.send_message(message, template_name="password_reset.html")



================================================
FILE: fastapi_backend/app/main.py
================================================
from fastapi import FastAPI
from fastapi_pagination import add_pagination
from .schemas import UserCreate, UserRead, UserUpdate
from .users import auth_backend, fastapi_users, AUTH_URL_PATH
from fastapi.middleware.cors import CORSMiddleware
from .utils import simple_generate_unique_route_id
from app.routes.items import router as items_router
from app.config import settings

app = FastAPI(
    generate_unique_id_function=simple_generate_unique_route_id,
    openapi_url=settings.OPENAPI_URL,
)

# Middleware for CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include authentication and user management routes
app.include_router(
    fastapi_users.get_auth_router(auth_backend),
    prefix=f"/{AUTH_URL_PATH}/jwt",
    tags=["auth"],
)
app.include_router(
    fastapi_users.get_register_router(UserRead, UserCreate),
    prefix=f"/{AUTH_URL_PATH}",
    tags=["auth"],
)
app.include_router(
    fastapi_users.get_reset_password_router(),
    prefix=f"/{AUTH_URL_PATH}",
    tags=["auth"],
)
app.include_router(
    fastapi_users.get_verify_router(UserRead),
    prefix=f"/{AUTH_URL_PATH}",
    tags=["auth"],
)
app.include_router(
    fastapi_users.get_users_router(UserRead, UserUpdate),
    prefix="/users",
    tags=["users"],
)

# Include items routes
app.include_router(items_router, prefix="/items")
add_pagination(app)



================================================
FILE: fastapi_backend/app/models.py
================================================
from fastapi_users.db import SQLAlchemyBaseUserTableUUID
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import Column, String, Integer, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
from uuid import uuid4


class Base(DeclarativeBase):
    pass


class User(SQLAlchemyBaseUserTableUUID, Base):
    items = relationship("Item", back_populates="user", cascade="all, delete-orphan")


class Item(Base):
    __tablename__ = "items"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)
    quantity = Column(Integer, nullable=True)
    user_id = Column(UUID(as_uuid=True), ForeignKey("user.id"), nullable=False)

    user = relationship("User", back_populates="items")



================================================
FILE: fastapi_backend/app/schemas.py
================================================
import uuid

from fastapi_users import schemas
from pydantic import BaseModel
from uuid import UUID


class UserRead(schemas.BaseUser[uuid.UUID]):
    pass


class UserCreate(schemas.BaseUserCreate):
    pass


class UserUpdate(schemas.BaseUserUpdate):
    pass


class ItemBase(BaseModel):
    name: str
    description: str | None = None
    quantity: int | None = None


class ItemCreate(ItemBase):
    pass


class ItemRead(ItemBase):
    id: UUID
    user_id: UUID

    model_config = {"from_attributes": True}



================================================
FILE: fastapi_backend/app/users.py
================================================
import uuid
import re

from typing import Optional

from fastapi import Depends, Request
from fastapi_users import (
    BaseUserManager,
    FastAPIUsers,
    UUIDIDMixin,
    InvalidPasswordException,
)

from fastapi_users.authentication import (
    AuthenticationBackend,
    BearerTransport,
    JWTStrategy,
)
from fastapi_users.db import SQLAlchemyUserDatabase

from .config import settings
from .database import get_user_db
from .email import send_reset_password_email
from .models import User
from .schemas import UserCreate

AUTH_URL_PATH = "auth"


class UserManager(UUIDIDMixin, BaseUserManager[User, uuid.UUID]):
    reset_password_token_secret = settings.RESET_PASSWORD_SECRET_KEY
    verification_token_secret = settings.VERIFICATION_SECRET_KEY

    async def on_after_register(self, user: User, request: Optional[Request] = None):
        print(f"User {user.id} has registered.")

    async def on_after_forgot_password(
        self, user: User, token: str, request: Optional[Request] = None
    ):
        await send_reset_password_email(user, token)

    async def on_after_request_verify(
        self, user: User, token: str, request: Optional[Request] = None
    ):
        print(f"Verification requested for user {user.id}. Verification token: {token}")

    async def validate_password(
        self,
        password: str,
        user: UserCreate,
    ) -> None:
        errors = []

        if len(password) < 8:
            errors.append("Password should be at least 8 characters.")
        if user.email in password:
            errors.append("Password should not contain e-mail.")
        if not any(char.isupper() for char in password):
            errors.append("Password should contain at least one uppercase letter.")
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            errors.append("Password should contain at least one special character.")

        if errors:
            raise InvalidPasswordException(reason=errors)


async def get_user_manager(user_db: SQLAlchemyUserDatabase = Depends(get_user_db)):
    yield UserManager(user_db)


bearer_transport = BearerTransport(tokenUrl=f"{AUTH_URL_PATH}/jwt/login")


def get_jwt_strategy() -> JWTStrategy:
    return JWTStrategy(
        secret=settings.ACCESS_SECRET_KEY,
        lifetime_seconds=settings.ACCESS_TOKEN_EXPIRE_SECONDS,
    )


auth_backend = AuthenticationBackend(
    name="jwt",
    transport=bearer_transport,
    get_strategy=get_jwt_strategy,
)

fastapi_users = FastAPIUsers[User, uuid.UUID](get_user_manager, [auth_backend])

current_active_user = fastapi_users.current_user(active=True)



================================================
FILE: fastapi_backend/app/utils.py
================================================
from fastapi.routing import APIRoute


def simple_generate_unique_route_id(route: APIRoute):
    return f"{route.tags[0]}-{route.name}"



================================================
FILE: fastapi_backend/app/email_templates/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/app/routes/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/app/routes/items.py
================================================
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi_pagination import Page, Params
from fastapi_pagination.ext.sqlalchemy import apaginate
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from app.database import User, get_async_session
from app.models import Item
from app.schemas import ItemRead, ItemCreate
from app.users import current_active_user

router = APIRouter(tags=["item"])


def transform_items(items):
    return [ItemRead.model_validate(item) for item in items]


@router.get("/", response_model=Page[ItemRead])
async def read_item(
    db: AsyncSession = Depends(get_async_session),
    user: User = Depends(current_active_user),
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(10, ge=1, le=100, description="Page size"),
):
    params = Params(page=page, size=size)
    query = select(Item).filter(Item.user_id == user.id)
    return await apaginate(db, query, params, transformer=transform_items)


@router.post("/", response_model=ItemRead)
async def create_item(
    item: ItemCreate,
    db: AsyncSession = Depends(get_async_session),
    user: User = Depends(current_active_user),
):
    db_item = Item(**item.model_dump(), user_id=user.id)
    db.add(db_item)
    await db.commit()
    await db.refresh(db_item)
    return db_item


@router.delete("/{item_id}")
async def delete_item(
    item_id: UUID,
    db: AsyncSession = Depends(get_async_session),
    user: User = Depends(current_active_user),
):
    result = await db.execute(
        select(Item).filter(Item.id == item_id, Item.user_id == user.id)
    )
    item = result.scalars().first()

    if not item:
        raise HTTPException(status_code=404, detail="Item not found or not authorized")

    await db.delete(item)
    await db.commit()

    return {"message": "Item successfully deleted"}



================================================
FILE: fastapi_backend/commands/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/commands/generate_openapi_schema.py
================================================
import json
from pathlib import Path
from app.main import app
import os

from dotenv import load_dotenv

load_dotenv()

OUTPUT_FILE = os.getenv("OPENAPI_OUTPUT_FILE")


def generate_openapi_schema(output_file):
    schema = app.openapi()
    output_path = Path(output_file)

    updated_schema = remove_operation_id_tag(schema)

    output_path.write_text(json.dumps(updated_schema, indent=2))
    print(f"OpenAPI schema saved to {output_file}")


def remove_operation_id_tag(schema):
    """
    Removes the tag prefix from the operation IDs in the OpenAPI schema.

    This cleans up the OpenAPI operation IDs that are used by the frontend
    client generator to create the names of the functions. The modified
    schema is then returned.
    """
    for path_data in schema["paths"].values():
        for operation in path_data.values():
            tag = operation["tags"][0]
            operation_id = operation["operationId"]
            to_remove = f"{tag}-"
            new_operation_id = operation_id[len(to_remove) :]
            operation["operationId"] = new_operation_id
    return schema


if __name__ == "__main__":
    generate_openapi_schema(OUTPUT_FILE)



================================================
FILE: fastapi_backend/tests/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/tests/conftest.py
================================================
from httpx import AsyncClient, ASGITransport
import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from fastapi_users.db import SQLAlchemyUserDatabase
from fastapi_users.password import PasswordHelper
import uuid

from app.config import settings
from app.models import User, Base

from app.database import get_user_db, get_async_session
from app.main import app
from app.users import get_jwt_strategy


@pytest_asyncio.fixture(scope="function")
async def engine():
    """Create a fresh test database engine for each test function."""
    engine = create_async_engine(settings.TEST_DATABASE_URL, echo=True)

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    await engine.dispose()


@pytest_asyncio.fixture(scope="function")
async def db_session(engine):
    """Create a fresh database session for each test."""
    async_session_maker = async_sessionmaker(
        engine, class_=AsyncSession, expire_on_commit=False
    )

    async with async_session_maker() as session:
        yield session
        await session.rollback()
        await session.close()


@pytest_asyncio.fixture(scope="function")
async def test_client(db_session):
    """Fixture to create a test client that uses the test database session."""

    # FastAPI-Users database override (wraps session with user operation helpers)
    async def override_get_user_db():
        session = SQLAlchemyUserDatabase(db_session, User)
        try:
            yield session
        finally:
            await db_session.close()

    # General database override (raw session access)
    async def override_get_async_session():
        try:
            yield db_session
        finally:
            await db_session.close()

    # Set up test database overrides
    app.dependency_overrides[get_user_db] = override_get_user_db
    app.dependency_overrides[get_async_session] = override_get_async_session

    async with AsyncClient(
        transport=ASGITransport(app=app), base_url="http://localhost:8000"
    ) as client:
        yield client


@pytest_asyncio.fixture(scope="function")
async def authenticated_user(test_client, db_session):
    """Fixture to create and authenticate a test user directly in the database."""

    # Create user data
    user_data = {
        "id": uuid.uuid4(),
        "email": "test@example.com",
        "hashed_password": PasswordHelper().hash("TestPassword123#"),
        "is_active": True,
        "is_superuser": False,
        "is_verified": True,
    }

    # Create user directly in database
    user = User(**user_data)
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)

    # Generate token using the strategy directly
    strategy = get_jwt_strategy()
    access_token = await strategy.write_token(user)

    # Return both the headers and the user data
    return {
        "headers": {"Authorization": f"Bearer {access_token}"},
        "user": user,
        "user_data": {"email": user_data["email"], "password": "TestPassword123#"},
    }



================================================
FILE: fastapi_backend/tests/test_database.py
================================================
import pytest
from sqlalchemy.ext.asyncio import AsyncSession, AsyncEngine
from fastapi_users.db import SQLAlchemyUserDatabase

from app.database import (
    async_session_maker,
    create_db_and_tables,
    get_async_session,
    get_user_db,
)
from app.models import Base, User


@pytest.fixture
async def mock_engine(mocker):
    # Mock the engine
    mock_engine = mocker.AsyncMock(spec=AsyncEngine)

    # Create a mock connection
    mock_conn = mocker.AsyncMock()
    mock_conn.run_sync = mocker.AsyncMock()

    # Set up the context manager properly
    mock_context = mocker.AsyncMock()
    mock_context.__aenter__.return_value = mock_conn
    mock_engine.begin.return_value = mock_context

    return mock_engine


@pytest.fixture
async def mock_session(mocker):
    # Create a mock session
    mock_session = mocker.AsyncMock(spec=AsyncSession)

    # Mock the session context manager
    mock_session.__aenter__.return_value = mock_session
    mock_session.__aexit__.return_value = None

    # Mock the session maker
    mock_session_maker = mocker.patch("app.database.async_session_maker")
    mock_session_maker.return_value = mock_session

    return mock_session


@pytest.mark.asyncio
async def test_create_db_and_tables(mock_engine, mocker):
    # Replace the real engine with our mock
    mocker.patch("app.database.engine", mock_engine)

    await create_db_and_tables()

    # Verify that begin was called
    mock_engine.begin.assert_called_once()

    # Verify that create_all was called
    mock_conn = mock_engine.begin.return_value.__aenter__.return_value
    mock_conn.run_sync.assert_called_once_with(Base.metadata.create_all)


@pytest.mark.asyncio
async def test_get_async_session(mock_session):
    # Test the session generator
    session_generator = get_async_session()
    session = await session_generator.__anext__()

    # Verify we got the mock session
    assert session == mock_session

    # Verify the session was created with the expected context
    mock_session.__aenter__.assert_called_once()


@pytest.mark.asyncio
async def test_get_user_db(mock_session):
    # Test the user db generator
    user_db_generator = get_user_db(mock_session)
    user_db = await user_db_generator.__anext__()

    # Verify we got a SQLAlchemyUserDatabase instance
    assert isinstance(user_db, SQLAlchemyUserDatabase)
    assert user_db.session == mock_session
    # Verify the model class is correct
    assert user_db.user_table == User


def test_engine_creation(mocker):
    # Mock settings
    mock_settings = mocker.patch("app.database.settings")
    mock_settings.DATABASE_URL = "sqlite+aiosqlite:///./test.db"
    mock_settings.EXPIRE_ON_COMMIT = False

    # Import engine to trigger creation with mocked settings
    from app.database import engine, async_session_maker

    # Verify engine is created
    assert isinstance(engine, AsyncEngine)

    # Verify session maker is configured
    assert async_session_maker.kw["expire_on_commit"] is False


@pytest.mark.asyncio
async def test_session_maker_configuration():
    # Create a test session
    async with async_session_maker() as session:
        assert isinstance(session, AsyncSession)



================================================
FILE: fastapi_backend/tests/test_email.py
================================================
import pytest
from pathlib import Path
from fastapi_mail import ConnectionConfig, MessageSchema
from app.email import get_email_config, send_reset_password_email
from app.models import User


@pytest.fixture
def mock_settings(mocker):
    mock = mocker.patch("app.email.settings")
    # Set up mock settings with test values
    mock.MAIL_USERNAME = "test_user"
    mock.MAIL_PASSWORD = "test_pass"
    mock.MAIL_FROM = "test@example.com"
    mock.MAIL_PORT = 587
    mock.MAIL_SERVER = "smtp.test.com"
    mock.MAIL_FROM_NAME = "Test Sender"
    mock.MAIL_STARTTLS = True
    mock.MAIL_SSL_TLS = False
    mock.USE_CREDENTIALS = True
    mock.VALIDATE_CERTS = True
    mock.TEMPLATE_DIR = "email_templates"
    mock.FRONTEND_URL = "http://test-frontend.com"
    return mock


@pytest.fixture
def mock_user():
    return User(
        email="user@example.com",
    )


def test_get_email_config(mock_settings):
    config = get_email_config()

    assert isinstance(config, ConnectionConfig)
    assert config.MAIL_USERNAME == "test_user"
    assert config.MAIL_PASSWORD == "test_pass"
    assert config.MAIL_FROM == "test@example.com"
    assert config.MAIL_PORT == 587
    assert config.MAIL_SERVER == "smtp.test.com"
    assert config.MAIL_FROM_NAME == "Test Sender"
    assert config.MAIL_STARTTLS
    assert not config.MAIL_SSL_TLS
    assert config.USE_CREDENTIALS
    assert config.VALIDATE_CERTS
    assert isinstance(config.TEMPLATE_FOLDER, Path)


@pytest.mark.asyncio
async def test_send_reset_password_email(mock_settings, mock_user, mocker):
    # Mock FastMail
    mock_fastmail = mocker.patch("app.email.FastMail")
    mock_fastmail_instance = mock_fastmail.return_value
    mock_fastmail_instance.send_message = mocker.AsyncMock()

    # Test data
    test_token = "test-token-123"

    # Call the function
    await send_reset_password_email(mock_user, test_token)

    # Verify FastMail was instantiated with correct config
    mock_fastmail.assert_called_once()
    config_arg = mock_fastmail.call_args[0][0]
    assert isinstance(config_arg, ConnectionConfig)

    # Verify send_message was called
    mock_fastmail_instance.send_message.assert_called_once()

    # Verify the message schema
    message_arg = mock_fastmail_instance.send_message.call_args[0][0]
    assert isinstance(message_arg, MessageSchema)
    assert message_arg.subject == "Password recovery"
    assert message_arg.recipients == [mock_user.email]

    # Verify template body contains correct data
    expected_link = (
        f"http://test-frontend.com/password-recovery/confirm?token={test_token}"
    )
    assert message_arg.template_body == {
        "username": mock_user.email,
        "link": expected_link,
    }

    # Verify template name
    template_name = mock_fastmail_instance.send_message.call_args[1]["template_name"]
    assert template_name == "password_reset.html"



================================================
FILE: fastapi_backend/tests/commands/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/tests/commands/test_generate_openapi_schema.py
================================================
import json
import os
import pytest
from pathlib import Path

from commands.generate_openapi_schema import (
    generate_openapi_schema,
    remove_operation_id_tag,
)


def load_json_file(filename):
    test_dir = os.path.dirname(__file__)
    file_path = os.path.join(test_dir, "files", filename)
    with open(file_path, "r") as f:
        return json.load(f)


@pytest.fixture
def sample_openapi_schema():
    return load_json_file("openapi_test.json")


@pytest.fixture
def expected_output_schema():
    return load_json_file("openapi_test_output.json")


def test_remove_operation_id_tag(sample_openapi_schema, expected_output_schema):
    cleaned_schema = remove_operation_id_tag(sample_openapi_schema)
    assert cleaned_schema == expected_output_schema


@pytest.fixture
def mock_app(mocker):
    app = mocker.patch("commands.generate_openapi_schema.app")
    app.openapi.return_value = {
        "openapi": "3.1.0",
        "info": {"title": "FastAPI", "version": "0.1.0"},
        "paths": {},
    }
    return app


def test_generate_openapi_schema(mocker, mock_app):
    mock_remove_operation_id_tag = mocker.patch(
        "commands.generate_openapi_schema.remove_operation_id_tag"
    )
    mock_remove_operation_id_tag.return_value = {"mocked_schema": True}

    output_file = "openapi_test.json"
    expected_output = json.dumps({"mocked_schema": True}, indent=2)

    generate_openapi_schema(output_file)

    mock_app.openapi.assert_called_once()
    mock_remove_operation_id_tag.assert_called_once_with(mock_app.openapi.return_value)

    output_path = Path(output_file)
    assert output_path.is_file()
    with open(output_file, "r") as f:
        content = f.read()
        assert content == expected_output

    output_path.unlink()



================================================
FILE: fastapi_backend/tests/commands/files/openapi_test.json
================================================
{
  "openapi": "3.1.0",
  "info": {
    "title": "FastAPI",
    "version": "0.1.0"
  },
  "paths": {
    "/auth/jwt/login": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Login",
        "operationId": "auth-auth:jwt.login_post",
        "requestBody": {
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/login_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BearerResponse"
                },
                "example": {
                  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiOTIyMWZmYzktNjQwZi00MzcyLTg2ZDMtY2U2NDJjYmE1NjAzIiwiYXVkIjoiZmFzdGFwaS11c2VyczphdXRoIiwiZXhwIjoxNTcxNTA0MTkzfQ.M10bjOe45I5Ncu_uXvOmVV8QxnL-nZfcH96U90JaocI",
                  "token_type": "bearer"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "LOGIN_BAD_CREDENTIALS": {
                    "summary": "Bad credentials or the user is inactive.",
                    "value": {
                      "detail": "LOGIN_BAD_CREDENTIALS"
                    }
                  },
                  "LOGIN_USER_NOT_VERIFIED": {
                    "summary": "The user is not verified.",
                    "value": {
                      "detail": "LOGIN_USER_NOT_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/jwt/logout": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Logout",
        "operationId": "auth-auth:jwt.logout_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/auth/register": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Register:Register",
        "operationId": "auth-register:register_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "REGISTER_USER_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "REGISTER_USER_ALREADY_EXISTS"
                    }
                  },
                  "REGISTER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "REGISTER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/forgot-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Forgot Password",
        "operationId": "auth-reset:forgot_password_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_forgot_password_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/reset-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Reset Password",
        "operationId": "auth-reset:reset_password_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_reset_password_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "RESET_PASSWORD_BAD_TOKEN": {
                    "summary": "Bad or expired token.",
                    "value": {
                      "detail": "RESET_PASSWORD_BAD_TOKEN"
                    }
                  },
                  "RESET_PASSWORD_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "RESET_PASSWORD_INVALID_PASSWORD",
                        "reason": "Password should be at least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/request-verify-token": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Request-Token",
        "operationId": "auth-verify:request-token_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_request-token_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/verify": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Verify",
        "operationId": "auth-verify:verify_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_verify_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "VERIFY_USER_BAD_TOKEN": {
                    "summary": "Bad token, not existing user ornot the e-mail currently set for the user.",
                    "value": {
                      "detail": "VERIFY_USER_BAD_TOKEN"
                    }
                  },
                  "VERIFY_USER_ALREADY_VERIFIED": {
                    "summary": "The user is already verified.",
                    "value": {
                      "detail": "VERIFY_USER_ALREADY_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/me": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:Current User",
        "operationId": "users-users:current_user_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch Current User",
        "operationId": "users-users:patch_current_user_patch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/users/{id}": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:User",
        "operationId": "users-users:user_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch User",
        "operationId": "users-users:patch_user_patch",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "400": {
            "content": {
              "application/json": {
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                }
              }
            },
            "description": "Bad Request"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "users"
        ],
        "summary": "Users:Delete User",
        "operationId": "users-users:delete_user_delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/authenticated-route": {
      "get": {
        "tags": [
          "custom-auth"
        ],
        "summary": "Authenticated Route",
        "operationId": "custom-auth-authenticated_route_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "BearerResponse": {
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access Token"
          },
          "token_type": {
            "type": "string",
            "title": "Token Type"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "token_type"
        ],
        "title": "BearerResponse"
      },
      "Body_auth-reset_forgot_password_post": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-reset:forgot_password_post"
      },
      "Body_auth-reset_reset_password_post": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          },
          "password": {
            "type": "string",
            "title": "Password"
          }
        },
        "type": "object",
        "required": [
          "token",
          "password"
        ],
        "title": "Body_auth-reset:reset_password_post"
      },
      "Body_auth-verify_request-token_post": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-verify:request-token_post"
      },
      "Body_auth-verify_verify_post": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          }
        },
        "type": "object",
        "required": [
          "token"
        ],
        "title": "Body_auth-verify:verify_post"
      },
      "ErrorModel": {
        "properties": {
          "detail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Detail"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ErrorModel"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "UserCreate": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "title": "UserCreate"
      },
      "UserRead": {
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Id"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "type": "boolean",
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "type": "boolean",
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "id",
          "email"
        ],
        "title": "UserRead"
      },
      "UserUpdate": {
        "properties": {
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Password"
          },
          "email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active"
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser"
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified"
          }
        },
        "type": "object",
        "title": "UserUpdate"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "login_post": {
        "properties": {
          "grant_type": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "password"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grant Type"
          },
          "username": {
            "type": "string",
            "title": "Username"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "default": ""
          },
          "client_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Id"
          },
          "client_secret": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Secret"
          }
        },
        "type": "object",
        "required": [
          "username",
          "password"
        ],
        "title": "Body_auth-auth:jwt.login_post"
      }
    },
    "securitySchemes": {
      "OAuth2PasswordBearer": {
        "type": "oauth2",
        "flows": {
          "password": {
            "scopes": {},
            "tokenUrl": "auth/jwt/login"
          }
        }
      }
    }
  }
}


================================================
FILE: fastapi_backend/tests/commands/files/openapi_test_output.json
================================================
{
  "openapi": "3.1.0",
  "info": {
    "title": "FastAPI",
    "version": "0.1.0"
  },
  "paths": {
    "/auth/jwt/login": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Login",
        "operationId": "auth:jwt.login_post",
        "requestBody": {
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/login_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BearerResponse"
                },
                "example": {
                  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiOTIyMWZmYzktNjQwZi00MzcyLTg2ZDMtY2U2NDJjYmE1NjAzIiwiYXVkIjoiZmFzdGFwaS11c2VyczphdXRoIiwiZXhwIjoxNTcxNTA0MTkzfQ.M10bjOe45I5Ncu_uXvOmVV8QxnL-nZfcH96U90JaocI",
                  "token_type": "bearer"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "LOGIN_BAD_CREDENTIALS": {
                    "summary": "Bad credentials or the user is inactive.",
                    "value": {
                      "detail": "LOGIN_BAD_CREDENTIALS"
                    }
                  },
                  "LOGIN_USER_NOT_VERIFIED": {
                    "summary": "The user is not verified.",
                    "value": {
                      "detail": "LOGIN_USER_NOT_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/jwt/logout": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Logout",
        "operationId": "auth:jwt.logout_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/auth/register": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Register:Register",
        "operationId": "register:register_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "REGISTER_USER_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "REGISTER_USER_ALREADY_EXISTS"
                    }
                  },
                  "REGISTER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "REGISTER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/forgot-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Forgot Password",
        "operationId": "reset:forgot_password_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_forgot_password_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/reset-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Reset Password",
        "operationId": "reset:reset_password_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_reset_password_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "RESET_PASSWORD_BAD_TOKEN": {
                    "summary": "Bad or expired token.",
                    "value": {
                      "detail": "RESET_PASSWORD_BAD_TOKEN"
                    }
                  },
                  "RESET_PASSWORD_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "RESET_PASSWORD_INVALID_PASSWORD",
                        "reason": "Password should be at least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/request-verify-token": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Request-Token",
        "operationId": "verify:request-token_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_request-token_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/verify": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Verify",
        "operationId": "verify:verify_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_verify_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "VERIFY_USER_BAD_TOKEN": {
                    "summary": "Bad token, not existing user ornot the e-mail currently set for the user.",
                    "value": {
                      "detail": "VERIFY_USER_BAD_TOKEN"
                    }
                  },
                  "VERIFY_USER_ALREADY_VERIFIED": {
                    "summary": "The user is already verified.",
                    "value": {
                      "detail": "VERIFY_USER_ALREADY_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/me": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:Current User",
        "operationId": "users:current_user_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch Current User",
        "operationId": "users:patch_current_user_patch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/users/{id}": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:User",
        "operationId": "users:user_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch User",
        "operationId": "users:patch_user_patch",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "400": {
            "content": {
              "application/json": {
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                }
              }
            },
            "description": "Bad Request"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "users"
        ],
        "summary": "Users:Delete User",
        "operationId": "users:delete_user_delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/authenticated-route": {
      "get": {
        "tags": [
          "custom-auth"
        ],
        "summary": "Authenticated Route",
        "operationId": "authenticated_route_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "BearerResponse": {
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access Token"
          },
          "token_type": {
            "type": "string",
            "title": "Token Type"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "token_type"
        ],
        "title": "BearerResponse"
      },
      "Body_auth-reset_forgot_password_post": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-reset:forgot_password_post"
      },
      "Body_auth-reset_reset_password_post": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          },
          "password": {
            "type": "string",
            "title": "Password"
          }
        },
        "type": "object",
        "required": [
          "token",
          "password"
        ],
        "title": "Body_auth-reset:reset_password_post"
      },
      "Body_auth-verify_request-token_post": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-verify:request-token_post"
      },
      "Body_auth-verify_verify_post": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          }
        },
        "type": "object",
        "required": [
          "token"
        ],
        "title": "Body_auth-verify:verify_post"
      },
      "ErrorModel": {
        "properties": {
          "detail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Detail"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ErrorModel"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "UserCreate": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "title": "UserCreate"
      },
      "UserRead": {
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Id"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "type": "boolean",
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "type": "boolean",
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "id",
          "email"
        ],
        "title": "UserRead"
      },
      "UserUpdate": {
        "properties": {
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Password"
          },
          "email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active"
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser"
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified"
          }
        },
        "type": "object",
        "title": "UserUpdate"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "login_post": {
        "properties": {
          "grant_type": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "password"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grant Type"
          },
          "username": {
            "type": "string",
            "title": "Username"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "default": ""
          },
          "client_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Id"
          },
          "client_secret": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Secret"
          }
        },
        "type": "object",
        "required": [
          "username",
          "password"
        ],
        "title": "Body_auth-auth:jwt.login_post"
      }
    },
    "securitySchemes": {
      "OAuth2PasswordBearer": {
        "type": "oauth2",
        "flows": {
          "password": {
            "scopes": {},
            "tokenUrl": "auth/jwt/login"
          }
        }
      }
    }
  }
}


================================================
FILE: fastapi_backend/tests/main/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/tests/main/test_main.py
================================================
import pytest
from fastapi import status
from fastapi_users.router import ErrorCode
from sqlalchemy import select
from app.models import User


class TestPasswordValidation:
    @pytest.mark.parametrize(
        "email, password, expected_status, expected_detail",
        [
            (
                "test@example.com",
                "short",
                status.HTTP_400_BAD_REQUEST,
                {
                    "detail": {
                        "code": ErrorCode.REGISTER_INVALID_PASSWORD.value,
                        "reason": ["Password should be at least 8 characters."],
                    }
                },
            ),
            (
                "test@example.com",
                "test@example.com",
                status.HTTP_400_BAD_REQUEST,
                {
                    "detail": {
                        "code": ErrorCode.REGISTER_INVALID_PASSWORD.value,
                        "reason": ["Password should not contain e-mail."],
                    }
                },
            ),
            (
                "test@example.com",
                "lowercasepassword",
                status.HTTP_400_BAD_REQUEST,
                {
                    "detail": {
                        "code": ErrorCode.REGISTER_INVALID_PASSWORD.value,
                        "reason": [
                            "Password should contain at least one uppercase letter."
                        ],
                    }
                },
            ),
            (
                "test@example.com",
                "Nosppecialchar1",
                status.HTTP_400_BAD_REQUEST,
                {
                    "detail": {
                        "code": ErrorCode.REGISTER_INVALID_PASSWORD.value,
                        "reason": [
                            "Password should contain at least one special character."
                        ],
                    }
                },
            ),
            (
                "test@example.com",
                "shorttest",
                status.HTTP_400_BAD_REQUEST,
                {
                    "detail": {
                        "code": ErrorCode.REGISTER_INVALID_PASSWORD.value,
                        "reason": [
                            "Password should be at least 8 characters.",
                            "Password should contain at least one uppercase letter.",
                            "Password should contain at least one special character.",
                        ],
                    }
                },
            ),
        ],
    )
    @pytest.mark.asyncio(loop_scope="function")
    async def test_password_validation(
        self, test_client, email, password, expected_status, expected_detail
    ):
        """Test user registration with password validation."""
        json = {"email": email, "password": password}
        response = await test_client.post("/auth/register", json=json)

        assert response.status_code == expected_status

    @pytest.mark.asyncio(loop_scope="function")
    async def test_register_user_with_valid_password(self, test_client, db_session):
        """Test user registration with success"""
        json = {
            "email": "user@1.com",
            "password": "Sppecialchar1#",
        }
        response = await test_client.post("/auth/register", json=json)

        row = await db_session.execute(select(User))

        user = row.scalars().first()

        assert response.status_code == status.HTTP_201_CREATED
        assert user is not None
        assert user.email == "user@1.com"



================================================
FILE: fastapi_backend/tests/routes/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/tests/routes/test_items.py
================================================
import pytest
from fastapi import status
from sqlalchemy import select, insert
from app.models import Item


class TestItems:
    @pytest.mark.asyncio(loop_scope="function")
    async def test_create_item(self, test_client, db_session, authenticated_user):
        """Test creating an item."""
        item_data = {"name": "Test Item", "description": "Test Description"}
        create_response = await test_client.post(
            "/items/", json=item_data, headers=authenticated_user["headers"]
        )

        assert create_response.status_code == status.HTTP_200_OK
        created_item = create_response.json()
        assert created_item["name"] == item_data["name"]
        assert created_item["description"] == item_data["description"]

        # Check if the item is in the database
        item = await db_session.execute(
            select(Item).where(Item.id == created_item["id"])
        )
        item = item.scalar()

        assert item is not None
        assert item.name == item_data["name"]
        assert item.description == item_data["description"]

    @pytest.mark.asyncio(loop_scope="function")
    async def test_read_items(self, test_client, db_session, authenticated_user):
        """Test reading items."""
        # Create multiple items
        items_data = [
            {
                "name": "First Item",
                "description": "First Description",
                "user_id": authenticated_user["user"].id,
            },
            {
                "name": "Second Item",
                "description": "Second Description",
                "user_id": authenticated_user["user"].id,
            },
        ]
        # create items in the database
        for item_data in items_data:
            await db_session.execute(insert(Item).values(**item_data))

        await db_session.commit()  # Add commit to ensure items are saved

        # Read items - test pagination response
        read_response = await test_client.get(
            "/items/", headers=authenticated_user["headers"]
        )
        assert read_response.status_code == status.HTTP_200_OK
        response_data = read_response.json()

        # Check pagination structure
        assert "items" in response_data
        assert "total" in response_data
        assert "page" in response_data
        assert "size" in response_data

        items = response_data["items"]

        # Filter items created in this test (to avoid interference from other tests)
        test_items = [
            item for item in items if item["name"] in ["First Item", "Second Item"]
        ]

        assert len(test_items) == 2
        assert any(item["name"] == "First Item" for item in test_items)
        assert any(item["name"] == "Second Item" for item in test_items)

    @pytest.mark.asyncio(loop_scope="function")
    async def test_delete_item(self, test_client, db_session, authenticated_user):
        """Test deleting an item."""
        # Create an item directly in the database
        item_data = {
            "name": "Item to Delete",
            "description": "Will be deleted",
            "user_id": authenticated_user["user"].id,
        }
        await db_session.execute(insert(Item).values(**item_data))

        # Get the created item from database
        db_item = (
            await db_session.execute(select(Item).where(Item.name == item_data["name"]))
        ).scalar()

        # Delete the item
        delete_response = await test_client.delete(
            f"/items/{db_item.id}", headers=authenticated_user["headers"]
        )
        assert delete_response.status_code == status.HTTP_200_OK

        # Verify item is deleted from database
        db_check = (
            await db_session.execute(select(Item).where(Item.id == db_item.id))
        ).scalar()
        assert db_check is None

    @pytest.mark.asyncio(loop_scope="function")
    async def test_delete_nonexistent_item(self, test_client, authenticated_user):
        """Test deleting an item that doesn't exist."""
        # Try to delete non-existent item
        delete_response = await test_client.delete(
            "/items/00000000-0000-0000-0000-000000000000",
            headers=authenticated_user["headers"],
        )
        assert delete_response.status_code == status.HTTP_404_NOT_FOUND

    @pytest.mark.asyncio(loop_scope="function")
    async def test_unauthorized_read_items(self, test_client):
        """Test reading items without authentication."""
        response = await test_client.get("/items/")
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    @pytest.mark.asyncio(loop_scope="function")
    async def test_unauthorized_create_item(self, test_client):
        """Test creating item without authentication."""
        item_data = {"name": "Unauthorized Item", "description": "Should fail"}
        response = await test_client.post("/items/", json=item_data)
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    @pytest.mark.asyncio(loop_scope="function")
    async def test_unauthorized_delete_item(self, test_client):
        """Test deleting item without authentication."""
        response = await test_client.delete(
            "/items/00000000-0000-0000-0000-000000000000"
        )
        assert response.status_code == status.HTTP_401_UNAUTHORIZED



================================================
FILE: fastapi_backend/tests/utils/__init__.py
================================================
[Empty file]


================================================
FILE: fastapi_backend/tests/utils/test_utils.py
================================================
from fastapi.routing import APIRoute
from app.utils import simple_generate_unique_route_id


def test_simple_generate_unique_route_id(mocker):
    mock_route = mocker.Mock(spec=APIRoute)

    mock_route.tags = ["auth"]
    mock_route.name = "authenticate_user"

    unique_id = simple_generate_unique_route_id(mock_route)

    assert unique_id == "auth-authenticate_user"



================================================
FILE: local-shared-data/openapi.json
================================================
{
  "openapi": "3.1.0",
  "info": {
    "title": "FastAPI",
    "version": "0.1.0"
  },
  "paths": {
    "/auth/jwt/login": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Login",
        "operationId": "auth:jwt.login",
        "requestBody": {
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/login"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BearerResponse"
                },
                "example": {
                  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiOTIyMWZmYzktNjQwZi00MzcyLTg2ZDMtY2U2NDJjYmE1NjAzIiwiYXVkIjoiZmFzdGFwaS11c2VyczphdXRoIiwiZXhwIjoxNTcxNTA0MTkzfQ.M10bjOe45I5Ncu_uXvOmVV8QxnL-nZfcH96U90JaocI",
                  "token_type": "bearer"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "LOGIN_BAD_CREDENTIALS": {
                    "summary": "Bad credentials or the user is inactive.",
                    "value": {
                      "detail": "LOGIN_BAD_CREDENTIALS"
                    }
                  },
                  "LOGIN_USER_NOT_VERIFIED": {
                    "summary": "The user is not verified.",
                    "value": {
                      "detail": "LOGIN_USER_NOT_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/jwt/logout": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Logout",
        "operationId": "auth:jwt.logout",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/auth/register": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Register:Register",
        "operationId": "register:register",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "REGISTER_USER_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "REGISTER_USER_ALREADY_EXISTS"
                    }
                  },
                  "REGISTER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "REGISTER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/forgot-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Forgot Password",
        "operationId": "reset:forgot_password",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_forgot_password"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/reset-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Reset Password",
        "operationId": "reset:reset_password",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_reset_password"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "RESET_PASSWORD_BAD_TOKEN": {
                    "summary": "Bad or expired token.",
                    "value": {
                      "detail": "RESET_PASSWORD_BAD_TOKEN"
                    }
                  },
                  "RESET_PASSWORD_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "RESET_PASSWORD_INVALID_PASSWORD",
                        "reason": "Password should be at least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/request-verify-token": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Request-Token",
        "operationId": "verify:request-token",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_request-token"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/verify": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Verify",
        "operationId": "verify:verify",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_verify"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "VERIFY_USER_BAD_TOKEN": {
                    "summary": "Bad token, not existing user ornot the e-mail currently set for the user.",
                    "value": {
                      "detail": "VERIFY_USER_BAD_TOKEN"
                    }
                  },
                  "VERIFY_USER_ALREADY_VERIFIED": {
                    "summary": "The user is already verified.",
                    "value": {
                      "detail": "VERIFY_USER_ALREADY_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/me": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:Current User",
        "operationId": "users:current_user",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch Current User",
        "operationId": "users:patch_current_user",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/users/{id}": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:User",
        "operationId": "users:user",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch User",
        "operationId": "users:patch_user",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "400": {
            "content": {
              "application/json": {
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                }
              }
            },
            "description": "Bad Request"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "users"
        ],
        "summary": "Users:Delete User",
        "operationId": "users:delete_user",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/items/": {
      "get": {
        "tags": [
          "item"
        ],
        "summary": "Read Item",
        "operationId": "read_item",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "description": "Page number",
              "default": 1,
              "title": "Page"
            },
            "description": "Page number"
          },
          {
            "name": "size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Page size",
              "default": 50,
              "title": "Size"
            },
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Page_ItemRead_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "item"
        ],
        "summary": "Create Item",
        "operationId": "create_item",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/items/{item_id}": {
      "delete": {
        "tags": [
          "item"
        ],
        "summary": "Delete Item",
        "operationId": "delete_item",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "item_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Item Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "BearerResponse": {
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access Token"
          },
          "token_type": {
            "type": "string",
            "title": "Token Type"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "token_type"
        ],
        "title": "BearerResponse"
      },
      "Body_auth-reset_forgot_password": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-reset:forgot_password"
      },
      "Body_auth-reset_reset_password": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          },
          "password": {
            "type": "string",
            "title": "Password"
          }
        },
        "type": "object",
        "required": [
          "token",
          "password"
        ],
        "title": "Body_auth-reset:reset_password"
      },
      "Body_auth-verify_request-token": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-verify:request-token"
      },
      "Body_auth-verify_verify": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          }
        },
        "type": "object",
        "required": [
          "token"
        ],
        "title": "Body_auth-verify:verify"
      },
      "ErrorModel": {
        "properties": {
          "detail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Detail"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ErrorModel"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "ItemCreate": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "quantity": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quantity"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ItemCreate"
      },
      "ItemRead": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "quantity": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quantity"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Id"
          },
          "user_id": {
            "type": "string",
            "format": "uuid",
            "title": "User Id"
          }
        },
        "type": "object",
        "required": [
          "name",
          "id",
          "user_id"
        ],
        "title": "ItemRead"
      },
      "Page_ItemRead_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/ItemRead"
            },
            "type": "array",
            "title": "Items"
          },
          "total": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Total"
          },
          "page": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Page"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "pages": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Pages"
          }
        },
        "type": "object",
        "required": [
          "items",
          "page",
          "size"
        ],
        "title": "Page[ItemRead]"
      },
      "UserCreate": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "title": "UserCreate"
      },
      "UserRead": {
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Id"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "type": "boolean",
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "type": "boolean",
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "id",
          "email"
        ],
        "title": "UserRead"
      },
      "UserUpdate": {
        "properties": {
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Password"
          },
          "email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active"
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser"
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified"
          }
        },
        "type": "object",
        "title": "UserUpdate"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "login": {
        "properties": {
          "grant_type": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "password"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grant Type"
          },
          "username": {
            "type": "string",
            "title": "Username"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "default": ""
          },
          "client_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Id"
          },
          "client_secret": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Secret"
          }
        },
        "type": "object",
        "required": [
          "username",
          "password"
        ],
        "title": "Body_auth-auth:jwt.login"
      }
    },
    "securitySchemes": {
      "OAuth2PasswordBearer": {
        "type": "oauth2",
        "flows": {
          "password": {
            "scopes": {},
            "tokenUrl": "auth/jwt/login"
          }
        }
      }
    }
  }
}


================================================
FILE: nextjs-frontend/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}



================================================
FILE: nextjs-frontend/jest.config.ts
================================================
/**
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

import type { Config } from "jest";
import nextJest from "next/jest.js";

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: "./",
});

const config: Config = {
  // All imported modules in your tests should be mocked automatically
  // automock: false,

  // Stop running tests after `n` failures
  // bail: 0,

  // The directory where Jest should store its cached dependency information
  // cacheDirectory: "/tmp/jest_rs",

  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  // collectCoverage: false,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // collectCoverageFrom: undefined,

  // The directory where Jest should output its coverage files
  // coverageDirectory: undefined,

  // An array of regexp pattern strings used to skip coverage collection
  // coveragePathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // Indicates which provider should be used to instrument code for coverage
  coverageProvider: "v8",

  // A list of reporter names that Jest uses when writing coverage reports
  // coverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // coverageThreshold: undefined,

  // A path to a custom dependency extractor
  // dependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // errorOnDeprecated: false,

  // The default configuration for fake timers
  // fakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // forceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // globalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // globalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // maxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  // moduleDirectories: [
  //   "node_modules"
  // ],

  // An array of file extensions your modules use
  // moduleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  // moduleNameMapper: {},

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  // modulePathIgnorePatterns: [],

  // Activates notifications for test results
  // notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // notifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  // preset: undefined,

  // Run tests from one or more projects
  // projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  // reporters: undefined,

  // Automatically reset mock state before every test
  // resetMocks: false,

  // Reset the module registry before running each individual test
  // resetModules: false,

  // A path to a custom resolver
  // resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // restoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // rootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  // roots: [
  //   "<rootDir>"
  // ],

  // Allows you to use a custom runner instead of Jest's default test runner
  // runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // setupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  // setupFilesAfterEnv: [],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // slowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // snapshotSerializers: [],

  // The test environment that will be used for testing
  // testEnvironment: "jest-environment-node",
  testEnvironment: "jsdom",

  // Options that will be passed to the testEnvironment
  // testEnvironmentOptions: {},

  // Adds a location field to test results
  // testLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // testMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // testPathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // testRegex: [],

  // This option allows the use of a custom results processor
  // testResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // testRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // transformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // unmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // verbose: undefined,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // watchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // watchman: true,
};

export default createJestConfig(config);



================================================
FILE: nextjs-frontend/middleware.ts
================================================
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { usersCurrentUser } from "@/app/clientService";

export async function middleware(request: NextRequest) {
  const token = request.cookies.get("accessToken");

  if (!token) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  const options = {
    headers: {
      Authorization: `Bearer ${token.value}`,
    },
  };

  const { error } = await usersCurrentUser(options);

  if (error) {
    return NextResponse.redirect(new URL("/login", request.url));
  }
  return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard/:path*"],
};



================================================
FILE: nextjs-frontend/openapi-ts.config.ts
================================================
import { defineConfig } from "@hey-api/openapi-ts";
import { config } from "dotenv";

config({ path: ".env.local" });

const openapiFile = process.env.OPENAPI_OUTPUT_FILE;

export default defineConfig({
  client: "@hey-api/client-axios",
  input: openapiFile as string,
  output: {
    format: "prettier",
    lint: "eslint",
    path: "app/openapi-client",
  },
});



================================================
FILE: nextjs-frontend/openapi.json
================================================
{
  "openapi": "3.1.0",
  "info": {
    "title": "FastAPI",
    "version": "0.1.0"
  },
  "paths": {
    "/auth/jwt/login": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Login",
        "operationId": "auth:jwt.login",
        "requestBody": {
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/login"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BearerResponse"
                },
                "example": {
                  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiOTIyMWZmYzktNjQwZi00MzcyLTg2ZDMtY2U2NDJjYmE1NjAzIiwiYXVkIjoiZmFzdGFwaS11c2VyczphdXRoIiwiZXhwIjoxNTcxNTA0MTkzfQ.M10bjOe45I5Ncu_uXvOmVV8QxnL-nZfcH96U90JaocI",
                  "token_type": "bearer"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "LOGIN_BAD_CREDENTIALS": {
                    "summary": "Bad credentials or the user is inactive.",
                    "value": {
                      "detail": "LOGIN_BAD_CREDENTIALS"
                    }
                  },
                  "LOGIN_USER_NOT_VERIFIED": {
                    "summary": "The user is not verified.",
                    "value": {
                      "detail": "LOGIN_USER_NOT_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/jwt/logout": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Auth:Jwt.Logout",
        "operationId": "auth:jwt.logout",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/auth/register": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Register:Register",
        "operationId": "register:register",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "REGISTER_USER_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "REGISTER_USER_ALREADY_EXISTS"
                    }
                  },
                  "REGISTER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "REGISTER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/forgot-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Forgot Password",
        "operationId": "reset:forgot_password",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_forgot_password"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/reset-password": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reset:Reset Password",
        "operationId": "reset:reset_password",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-reset_reset_password"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "RESET_PASSWORD_BAD_TOKEN": {
                    "summary": "Bad or expired token.",
                    "value": {
                      "detail": "RESET_PASSWORD_BAD_TOKEN"
                    }
                  },
                  "RESET_PASSWORD_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "RESET_PASSWORD_INVALID_PASSWORD",
                        "reason": "Password should be at least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/request-verify-token": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Request-Token",
        "operationId": "verify:request-token",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_request-token"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/verify": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Verify:Verify",
        "operationId": "verify:verify",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_auth-verify_verify"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "VERIFY_USER_BAD_TOKEN": {
                    "summary": "Bad token, not existing user ornot the e-mail currently set for the user.",
                    "value": {
                      "detail": "VERIFY_USER_BAD_TOKEN"
                    }
                  },
                  "VERIFY_USER_ALREADY_VERIFIED": {
                    "summary": "The user is already verified.",
                    "value": {
                      "detail": "VERIFY_USER_ALREADY_VERIFIED"
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/me": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:Current User",
        "operationId": "users:current_user",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch Current User",
        "operationId": "users:patch_current_user",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                },
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/users/{id}": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Users:User",
        "operationId": "users:user",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "users"
        ],
        "summary": "Users:Patch User",
        "operationId": "users:patch_user",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRead"
                }
              }
            }
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "400": {
            "content": {
              "application/json": {
                "examples": {
                  "UPDATE_USER_EMAIL_ALREADY_EXISTS": {
                    "summary": "A user with this email already exists.",
                    "value": {
                      "detail": "UPDATE_USER_EMAIL_ALREADY_EXISTS"
                    }
                  },
                  "UPDATE_USER_INVALID_PASSWORD": {
                    "summary": "Password validation failed.",
                    "value": {
                      "detail": {
                        "code": "UPDATE_USER_INVALID_PASSWORD",
                        "reason": "Password should beat least 3 characters"
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/ErrorModel"
                }
              }
            },
            "description": "Bad Request"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "users"
        ],
        "summary": "Users:Delete User",
        "operationId": "users:delete_user",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "401": {
            "description": "Missing token or inactive user."
          },
          "403": {
            "description": "Not a superuser."
          },
          "404": {
            "description": "The user does not exist."
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/items/": {
      "get": {
        "tags": [
          "item"
        ],
        "summary": "Read Item",
        "operationId": "read_item",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "description": "Page number",
              "default": 1,
              "title": "Page"
            },
            "description": "Page number"
          },
          {
            "name": "size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Page size",
              "default": 50,
              "title": "Size"
            },
            "description": "Page size"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Page_ItemRead_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "item"
        ],
        "summary": "Create Item",
        "operationId": "create_item",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/items/{item_id}": {
      "delete": {
        "tags": [
          "item"
        ],
        "summary": "Delete Item",
        "operationId": "delete_item",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "item_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Item Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "BearerResponse": {
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access Token"
          },
          "token_type": {
            "type": "string",
            "title": "Token Type"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "token_type"
        ],
        "title": "BearerResponse"
      },
      "Body_auth-reset_forgot_password": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-reset:forgot_password"
      },
      "Body_auth-reset_reset_password": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          },
          "password": {
            "type": "string",
            "title": "Password"
          }
        },
        "type": "object",
        "required": [
          "token",
          "password"
        ],
        "title": "Body_auth-reset:reset_password"
      },
      "Body_auth-verify_request-token": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "Body_auth-verify:request-token"
      },
      "Body_auth-verify_verify": {
        "properties": {
          "token": {
            "type": "string",
            "title": "Token"
          }
        },
        "type": "object",
        "required": [
          "token"
        ],
        "title": "Body_auth-verify:verify"
      },
      "ErrorModel": {
        "properties": {
          "detail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Detail"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ErrorModel"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "ItemCreate": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "quantity": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quantity"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ItemCreate"
      },
      "ItemRead": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "quantity": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quantity"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Id"
          },
          "user_id": {
            "type": "string",
            "format": "uuid",
            "title": "User Id"
          }
        },
        "type": "object",
        "required": [
          "name",
          "id",
          "user_id"
        ],
        "title": "ItemRead"
      },
      "Page_ItemRead_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/ItemRead"
            },
            "type": "array",
            "title": "Items"
          },
          "total": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Total"
          },
          "page": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Page"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "pages": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Pages"
          }
        },
        "type": "object",
        "required": [
          "items",
          "page",
          "size"
        ],
        "title": "Page[ItemRead]"
      },
      "UserCreate": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "title": "UserCreate"
      },
      "UserRead": {
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Id"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "default": true
          },
          "is_superuser": {
            "type": "boolean",
            "title": "Is Superuser",
            "default": false
          },
          "is_verified": {
            "type": "boolean",
            "title": "Is Verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "id",
          "email"
        ],
        "title": "UserRead"
      },
      "UserUpdate": {
        "properties": {
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Password"
          },
          "email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active"
          },
          "is_superuser": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Superuser"
          },
          "is_verified": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Verified"
          }
        },
        "type": "object",
        "title": "UserUpdate"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "login": {
        "properties": {
          "grant_type": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "password"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grant Type"
          },
          "username": {
            "type": "string",
            "title": "Username"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "default": ""
          },
          "client_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Id"
          },
          "client_secret": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Secret"
          }
        },
        "type": "object",
        "required": [
          "username",
          "password"
        ],
        "title": "Body_auth-auth:jwt.login"
      }
    },
    "securitySchemes": {
      "OAuth2PasswordBearer": {
        "type": "oauth2",
        "flows": {
          "password": {
            "scopes": {},
            "tokenUrl": "auth/jwt/login"
          }
        }
      }
    }
  }
}


================================================
FILE: nextjs-frontend/package.json
================================================
{
  "name": "nextjs-frontend",
  "version": "0.0.6",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "generate-client": "openapi-ts",
    "test": "jest",
    "coverage": "jest --coverage",
    "prettier": "prettier --write '**/*.{js,jsx,ts,tsx,json,css,html}'",
    "tsc": "tsc"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@hey-api/client-axios": "^0.3.4",
    "@hey-api/client-fetch": "^0.4.0",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.1",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "dotenv": "^16.4.5",
    "lucide-react": "^0.452.0",
    "next": "15.5.0",
    "react": "19.1.1",
    "react-dom": "19.1.1",
    "react-hook-form": "^7.54.0",
    "react-icons": "^5.4.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.1",
    "@eslint/js": "^9.18.0",
    "@hey-api/openapi-ts": "^0.60.1",
    "@next/eslint-plugin-next": "15.5.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.0.1",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/react": "19.1.11",
    "@types/react-dom": "19.1.7",
    "@typescript-eslint/eslint-plugin": "^8.20.0",
    "autoprefixer": "^10.4.20",
    "chokidar": "^4.0.1",
    "chokidar-cli": "^3.0.0",
    "eslint": "^9.18.0",
    "eslint-config-next": "15.5.0",
    "eslint-config-prettier": "^10.0.1",
    "fork-ts-checker-webpack-plugin": "^9.0.2",
    "globals": "^15.14.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "^8.4.47",
    "prettier": "^3.3.3",
    "tailwindcss": "^3.4.13",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5",
    "typescript-eslint": "^8.20.0"
  },
  "overrides": {
    "@types/react": "19.1.11",
    "@types/react-dom": "19.1.7"
  },
  "packageManager": "pbun@10.7.1+sha512.2d92c86b7928dc8284f53494fb4201f983da65f0fb4f0d40baafa5cf628fa31dae3e5968f12466f17df7e97310e30f343a648baea1b9b350685dafafffdf5808"
}



================================================
FILE: nextjs-frontend/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "target": "ES2017"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: nextjs-frontend/vercel.json
================================================
{
  "git": {
    "deploymentEnabled": {
      "main": false
    }
  }
}



================================================
FILE: nextjs-frontend/__tests__/login.test.tsx
================================================
import { login } from "@/components/actions/login-action";
import { authJwtLogin } from "@/app/clientService";
import { cookies } from "next/headers";

jest.mock("../app/clientService", () => ({
  authJwtLogin: jest.fn(),
}));

jest.mock("next/headers", () => {
  const mockSet = jest.fn();
  return { cookies: jest.fn().mockResolvedValue({ set: mockSet }) };
});

jest.mock("next/navigation", () => ({
  redirect: jest.fn(),
}));

describe("login action", () => {
  it("should call login service action with the correct input", async () => {
    const formData = new FormData();
    formData.set("username", "a@a.com");
    formData.set("password", "Q12341414#");

    const mockSet = (await cookies()).set;

    // Mock a successful login
    (authJwtLogin as jest.Mock).mockResolvedValue({
      data: { access_token: "1245token" },
    });

    await login({}, formData);

    expect(authJwtLogin).toHaveBeenCalledWith({
      body: {
        username: "a@a.com",
        password: "Q12341414#",
      },
    });

    expect(cookies).toHaveBeenCalled();
    expect(mockSet).toHaveBeenCalledWith("accessToken", "1245token");
  });

  it("should should return an error if the server validation fails", async () => {
    const formData = new FormData();
    formData.set("username", "invalid@invalid.com");
    formData.set("password", "Q12341414#");

    // Mock a failed login
    (authJwtLogin as jest.Mock).mockResolvedValue({
      error: {
        detail: "LOGIN_BAD_CREDENTIALS",
      },
    });

    const result = await login(undefined, formData);

    expect(authJwtLogin).toHaveBeenCalledWith({
      body: {
        username: "invalid@invalid.com",
        password: "Q12341414#",
      },
    });

    expect(result).toEqual({
      server_validation_error: "LOGIN_BAD_CREDENTIALS",
    });

    expect(cookies).not.toHaveBeenCalled();
  });

  it("should should return an error if either the password or username is not sent", async () => {
    const formData = new FormData();
    formData.set("username", "");
    formData.set("password", "");

    const result = await login({}, formData);

    expect(authJwtLogin).not.toHaveBeenCalledWith();

    expect(result).toEqual({
      errors: {
        password: ["Password is required"],
        username: ["Username is required"],
      },
    });

    expect(cookies).not.toHaveBeenCalled();
  });

  it("should handle unexpected errors and return server error message", async () => {
    // Mock the authJwtLogin to throw an error
    const mockError = new Error("Network error");
    (authJwtLogin as jest.Mock).mockRejectedValue(mockError);

    const formData = new FormData();
    formData.append("username", "testuser");
    formData.append("password", "password123");

    const result = await login(undefined, formData);

    expect(result).toEqual({
      server_error: "An unexpected error occurred. Please try again later.",
    });
  });
});



================================================
FILE: nextjs-frontend/__tests__/loginPage.test.tsx
================================================
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";

import Page from "@/app/login/page";
import { login } from "@/components/actions/login-action";

jest.mock("../components/actions/login-action", () => ({
  login: jest.fn(),
}));

describe("Login Page", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("renders the form with username and password input and submit button", () => {
    render(<Page />);

    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /sign in/i }),
    ).toBeInTheDocument();
  });

  it("calls login in successful form submission", async () => {
    (login as jest.Mock).mockResolvedValue({});

    render(<Page />);

    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign in/i });

    fireEvent.change(usernameInput, {
      target: { value: "testuser@example.com" },
    });
    fireEvent.change(passwordInput, { target: { value: "#123176a@" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      const formData = new FormData();
      formData.set("username", "testuser@example.com");
      formData.set("password", "#123176a@");
      expect(login).toHaveBeenCalledWith(undefined, formData);
    });
  });

  it("displays error message if login fails", async () => {
    // Mock a failed login
    (login as jest.Mock).mockResolvedValue({
      server_validation_error: "LOGIN_BAD_CREDENTIALS",
    });

    render(<Page />);

    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign in/i });

    fireEvent.change(usernameInput, { target: { value: "wrong@example.com" } });
    fireEvent.change(passwordInput, { target: { value: "wrongpass" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText("LOGIN_BAD_CREDENTIALS")).toBeInTheDocument();
    });
  });

  it("displays server error for unexpected errors", async () => {
    (login as jest.Mock).mockResolvedValue({
      server_error: "An unexpected error occurred. Please try again later.",
    });

    render(<Page />);

    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign in/i });

    fireEvent.change(usernameInput, { target: { value: "test@test.com" } });
    fireEvent.change(passwordInput, { target: { value: "password123" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(
        screen.getByText(
          "An unexpected error occurred. Please try again later.",
        ),
      ).toBeInTheDocument();
    });
  });
});



================================================
FILE: nextjs-frontend/__tests__/passwordReset.test.tsx
================================================
import { passwordReset } from "@/components/actions/password-reset-action";
import { resetForgotPassword } from "@/app/clientService";

jest.mock("../app/openapi-client/sdk.gen", () => ({
  resetForgotPassword: jest.fn(),
}));

jest.mock("../lib/clientConfig", () => ({
  client: {
    setConfig: jest.fn(),
  },
}));

describe("passwordReset action", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should call resetForgotPassword with the correct input and return success message", async () => {
    const formData = new FormData();
    formData.set("email", "testuser@example.com");
    // Mock a successful password reset
    (resetForgotPassword as jest.Mock).mockResolvedValue({});

    const result = await passwordReset({}, formData);

    expect(resetForgotPassword).toHaveBeenCalledWith({
      body: { email: "testuser@example.com" },
    });
    expect(result).toEqual({
      message: "Password reset instructions sent to your email.",
    });
  });

  it("should return a server validation error if the server call fails", async () => {
    const formData = new FormData();
    formData.set("email", "testuser@example.com");

    // Mock a failed password reset
    (resetForgotPassword as jest.Mock).mockResolvedValue({
      error: { detail: "User not found" },
    });

    const result = await passwordReset({}, formData);

    expect(result).toEqual({ server_validation_error: "User not found" });
    expect(resetForgotPassword).toHaveBeenCalledWith({
      body: { email: "testuser@example.com" },
    });
  });

  it("should handle unexpected errors and return server error message", async () => {
    // Mock the resetForgotPassword to throw an error
    const mockError = new Error("Network error");
    (resetForgotPassword as jest.Mock).mockRejectedValue(mockError);

    const formData = new FormData();
    formData.append("email", "testuser@example.com");

    const result = await passwordReset(undefined, formData);

    expect(result).toEqual({
      server_error: "An unexpected error occurred. Please try again later.",
    });
  });
});



================================================
FILE: nextjs-frontend/__tests__/passwordResetConfirm.test.tsx
================================================
import { passwordResetConfirm } from "@/components/actions/password-reset-action";
import { resetResetPassword } from "@/app/clientService";
import { redirect } from "next/navigation";

jest.mock("next/navigation", () => ({
  redirect: jest.fn(),
}));

jest.mock("../app/openapi-client/sdk.gen", () => ({
  resetResetPassword: jest.fn(),
}));

jest.mock("../lib/clientConfig", () => ({
  client: {
    setConfig: jest.fn(),
  },
}));

describe("passwordReset action", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should call resetPassword with the correct input", async () => {
    const formData = new FormData();
    formData.set("resetToken", "token");
    formData.set("password", "P12345678#");
    formData.set("passwordConfirm", "P12345678#");
    // Mock a successful password reset confirm
    (resetResetPassword as jest.Mock).mockResolvedValue({});

    await passwordResetConfirm({}, formData);

    expect(resetResetPassword).toHaveBeenCalledWith({
      body: { token: "token", password: "P12345678#" },
    });
    expect(redirect).toHaveBeenCalled();
  });

  it("should return an error message if password reset fails", async () => {
    const formData = new FormData();
    formData.set("resetToken", "invalid_token");
    formData.set("password", "P12345678#");
    formData.set("passwordConfirm", "P12345678#");

    // Mock a failed password reset
    (resetResetPassword as jest.Mock).mockResolvedValue({
      error: { detail: "Invalid token" },
    });

    const result = await passwordResetConfirm(undefined, formData);

    expect(result).toEqual({ server_validation_error: "Invalid token" });
    expect(resetResetPassword).toHaveBeenCalledWith({
      body: { token: "invalid_token", password: "P12345678#" },
    });
  });

  it("should return an validation error if passwords are invalid and don't match", async () => {
    const formData = new FormData();
    formData.set("resetToken", "token");
    formData.set("password", "12345678#");
    formData.set("passwordConfirm", "45678#");

    const result = await passwordResetConfirm(undefined, formData);

    expect(result).toEqual({
      errors: {
        password: ["Password should contain at least one uppercase letter."],
        passwordConfirm: ["Passwords must match."],
      },
    });
    expect(resetResetPassword).not.toHaveBeenCalledWith();
  });

  it("should handle unexpected errors and return server error message", async () => {
    // Mock the resetResetPassword to throw an error
    const mockError = new Error("Network error");
    (resetResetPassword as jest.Mock).mockRejectedValue(mockError);

    const formData = new FormData();
    formData.append("resetToken", "token");
    formData.append("password", "P12345678#");
    formData.append("passwordConfirm", "P12345678#");

    const result = await passwordResetConfirm(undefined, formData);

    expect(result).toEqual({
      server_error: "An unexpected error occurred. Please try again later.",
    });
  });
});



================================================
FILE: nextjs-frontend/__tests__/passwordResetConfirmPage.test.tsx
================================================
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";

import Page from "@/app/password-recovery/confirm/page";
import { passwordResetConfirm } from "@/components/actions/password-reset-action";
import { useSearchParams, notFound } from "next/navigation";

jest.mock("next/navigation", () => ({
  ...jest.requireActual("next/navigation"),
  useSearchParams: jest.fn(),
  notFound: jest.fn(),
}));

jest.mock("../components/actions/password-reset-action", () => ({
  passwordResetConfirm: jest.fn(),
}));

describe("Password Reset Confirm Page", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("renders the form with password and confirm password input and submit button", () => {
    (useSearchParams as jest.Mock).mockImplementation(() => ({
      get: (key: string) => (key === "token" ? "mock-token" : null),
    }));

    render(<Page />);

    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByLabelText("Password Confirm")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /send/i })).toBeInTheDocument();
  });

  it("renders the 404 page in case there is not a token", () => {
    (useSearchParams as jest.Mock).mockImplementation(() => ({
      get: (key: string) => (key === "token" ? "" : undefined),
    }));

    render(<Page />);

    expect(notFound).toHaveBeenCalled();
  });

  it("displays error message if password reset fails", async () => {
    (useSearchParams as jest.Mock).mockImplementation(() => ({
      get: (key: string) => (key === "token" ? "invalid-mock-token" : null),
    }));

    // Mock a successful password reset
    (passwordResetConfirm as jest.Mock).mockResolvedValue({
      server_validation_error: "Invalid Token",
    });

    render(<Page />);

    const password = screen.getByLabelText("Password");
    const passwordConfirm = screen.getByLabelText("Password Confirm");

    const submitButton = screen.getByRole("button", { name: /send/i });

    fireEvent.change(password, { target: { value: "P12345678#" } });
    fireEvent.change(passwordConfirm, { target: { value: "P12345678#" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText("Invalid Token")).toBeInTheDocument();
    });

    const formData = new FormData();
    formData.set("password", "P12345678#");
    formData.set("passwordConfirm", "P12345678#");
    formData.set("resetToken", "invalid-mock-token");
    expect(passwordResetConfirm).toHaveBeenCalledWith(undefined, formData);
  });
  it("displays validation errors if password is invalid and don't match", async () => {
    (useSearchParams as jest.Mock).mockImplementation(() => ({
      get: (key: string) => (key === "token" ? "mock-token" : null),
    }));

    // Mock a successful password reset
    (passwordResetConfirm as jest.Mock).mockResolvedValue({
      errors: {
        password: ["Password should contain at least one uppercase letter."],
        passwordConfirm: ["Passwords must match."],
      },
    });

    render(<Page />);

    const password = screen.getByLabelText("Password");
    const passwordConfirm = screen.getByLabelText("Password Confirm");

    const submitButton = screen.getByRole("button", { name: /send/i });

    fireEvent.change(password, { target: { value: "12345678#" } });
    fireEvent.change(passwordConfirm, { target: { value: "45678#" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(
        screen.getByText(
          "Password should contain at least one uppercase letter.",
        ),
      ).toBeInTheDocument();
      expect(screen.getByText("Passwords must match.")).toBeInTheDocument();
    });

    const formData = new FormData();
    formData.set("password", "12345678#");
    formData.set("passwordConfirm", "45678#");
    formData.set("resetToken", "mock-token");
    expect(passwordResetConfirm).toHaveBeenCalledWith(undefined, formData);
  });
});



================================================
FILE: nextjs-frontend/__tests__/passwordResetPage.test.tsx
================================================
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";

import Page from "@/app/password-recovery/page";
import { passwordReset } from "@/components/actions/password-reset-action";

jest.mock("../components/actions/password-reset-action", () => ({
  passwordReset: jest.fn(),
}));

describe("Password Reset Page", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("renders the form with email input and submit button", () => {
    render(<Page />);

    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /send/i })).toBeInTheDocument();
  });

  it("displays success message on successful form submission", async () => {
    // Mock a successful password reset
    (passwordReset as jest.Mock).mockResolvedValue({
      message: "Password reset instructions sent to your email.",
    });

    render(<Page />);

    const emailInput = screen.getByLabelText(/email/i);
    const submitButton = screen.getByRole("button", { name: /send/i });

    fireEvent.change(emailInput, { target: { value: "testuser@example.com" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(
        screen.getByText("Password reset instructions sent to your email."),
      ).toBeInTheDocument();
    });

    const formData = new FormData();
    formData.set("email", "testuser@example.com");
    expect(passwordReset).toHaveBeenCalledWith(undefined, formData);
  });

  it("displays error message if password reset fails", async () => {
    // Mock a failed password reset
    (passwordReset as jest.Mock).mockResolvedValue({
      server_validation_error: "User not found",
    });

    render(<Page />);

    const emailInput = screen.getByLabelText(/email/i);
    const submitButton = screen.getByRole("button", { name: /send/i });

    fireEvent.change(emailInput, {
      target: { value: "invaliduser@example.com" },
    });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText("User not found")).toBeInTheDocument();
    });

    const formData = new FormData();
    formData.set("email", "invaliduser@example.com");
    expect(passwordReset).toHaveBeenCalledWith(undefined, formData);
  });
});



================================================
FILE: nextjs-frontend/__tests__/register.test.ts
================================================
import { register } from "@/components/actions/register-action";
import { redirect } from "next/navigation";
import { registerRegister } from "@/app/clientService";

jest.mock("next/navigation", () => ({
  redirect: jest.fn(),
}));

jest.mock("../app/clientService", () => ({
  registerRegister: jest.fn(),
}));

describe("register action", () => {
  it("should call register service action with the correct input", async () => {
    const formData = new FormData();
    formData.set("email", "a@a.com");
    formData.set("password", "Q12341414#");

    // Mock a successful register
    (registerRegister as jest.Mock).mockResolvedValue({});

    await register({}, formData);

    expect(registerRegister).toHaveBeenCalledWith({
      body: {
        email: "a@a.com",
        password: "Q12341414#",
      },
    });

    expect(redirect).toHaveBeenCalled();
  });
  it("should should return an error if the server call fails", async () => {
    const formData = new FormData();
    formData.set("email", "a@a.com");
    formData.set("password", "Q12341414#");

    // Mock a failed register
    (registerRegister as jest.Mock).mockResolvedValue({
      error: {
        detail: "REGISTER_USER_ALREADY_EXISTS",
      },
    });

    const result = await register({}, formData);

    expect(registerRegister).toHaveBeenCalledWith({
      body: {
        email: "a@a.com",
        password: "Q12341414#",
      },
    });
    expect(result).toEqual({
      server_validation_error: "REGISTER_USER_ALREADY_EXISTS",
    });
  });

  it("should return an validation error if the form is invalid", async () => {
    const formData = new FormData();
    formData.set("email", "email");
    formData.set("password", "invalid_password");

    const result = await register({}, formData);

    expect(result).toEqual({
      errors: {
        email: ["Invalid email address"],
        password: [
          "Password should contain at least one uppercase letter.",
          "Password should contain at least one special character.",
        ],
      },
    });
    expect(registerRegister).not.toHaveBeenCalledWith();
  });

  it("should handle unexpected errors and return server error message", async () => {
    // Mock the registerRegister to throw an error
    const mockError = new Error("Network error");
    (registerRegister as jest.Mock).mockRejectedValue(mockError);

    const formData = new FormData();
    formData.append("email", "testuser@example.com");
    formData.append("password", "Password123#");

    const result = await register(undefined, formData);

    expect(result).toEqual({
      server_error: "An unexpected error occurred. Please try again later.",
    });
  });
});



================================================
FILE: nextjs-frontend/__tests__/registerPage.test.tsx
================================================
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";

import Page from "@/app/register/page";
import { register } from "@/components/actions/register-action";

jest.mock("../components/actions/register-action", () => ({
  register: jest.fn(),
}));

describe("Register Page", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("renders the form with email and password input and submit button", () => {
    render(<Page />);

    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /sign up/i }),
    ).toBeInTheDocument();
  });

  it("displays success message on successful form submission", async () => {
    // Mock a successful register
    (register as jest.Mock).mockResolvedValue({});

    render(<Page />);

    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign up/i });

    fireEvent.change(emailInput, { target: { value: "testuser@example.com" } });
    fireEvent.change(passwordInput, { target: { value: "@1231231%a" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      const formData = new FormData();
      formData.set("email", "testuser@example.com");
      formData.set("password", "@1231231%a");
      expect(register).toHaveBeenCalledWith(undefined, formData);
    });
  });

  it("displays server validation error if register fails", async () => {
    (register as jest.Mock).mockResolvedValue({
      server_validation_error: "User already exists",
    });

    render(<Page />);

    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign up/i });

    fireEvent.change(emailInput, { target: { value: "already@already.com" } });
    fireEvent.change(passwordInput, { target: { value: "@1231231%a" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText("User already exists")).toBeInTheDocument();
    });
  });

  it("displays server error for unexpected errors", async () => {
    (register as jest.Mock).mockResolvedValue({
      server_error: "An unexpected error occurred. Please try again later.",
    });

    render(<Page />);

    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign up/i });

    fireEvent.change(emailInput, { target: { value: "test@test.com" } });
    fireEvent.change(passwordInput, { target: { value: "@1231231%a" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(
        screen.getByText(
          "An unexpected error occurred. Please try again later.",
        ),
      ).toBeInTheDocument();
    });

    const formData = new FormData();
    formData.set("email", "test@test.com");
    formData.set("password", "@1231231%a");
    expect(register).toHaveBeenCalledWith(undefined, formData);
  });

  it("displays validation errors if password and email are invalid", async () => {
    // Mock a successful password register
    (register as jest.Mock).mockResolvedValue({
      errors: {
        email: ["Invalid email address"],
        password: [
          "Password should contain at least one uppercase letter.",
          "Password should contain at least one special character.",
        ],
      },
    });

    render(<Page />);

    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole("button", { name: /sign up/i });

    fireEvent.change(emailInput, { target: { value: "email@email.com" } });
    fireEvent.change(passwordInput, { target: { value: "invalid_password" } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(
        screen.getByText(
          "Password should contain at least one uppercase letter.",
        ),
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          "Password should contain at least one special character.",
        ),
      ).toBeInTheDocument();
      expect(screen.getByText("Invalid email address")).toBeInTheDocument();
    });

    const formData = new FormData();
    formData.set("email", "email@email.com");
    formData.set("password", "invalid_password");
    expect(register).toHaveBeenCalledWith(undefined, formData);
  });
});



================================================
FILE: nextjs-frontend/app/clientService.ts
================================================
export * from "./openapi-client";

import "@/lib/clientConfig";



================================================
FILE: nextjs-frontend/app/layout.tsx
================================================
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        {children}
      </body>
    </html>
  );
}



================================================
FILE: nextjs-frontend/app/page.tsx
================================================
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { FaGithub } from "react-icons/fa";
import { Badge } from "@/components/ui/badge";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center bg-gray-50 dark:bg-gray-900 p-8">
      <div className="text-center max-w-2xl">
        <h1 className="text-5xl font-bold text-gray-800 dark:text-white mb-6">
          Welcome to the Next.js & FastAPI Boilerplate
        </h1>
        <p className="text-lg text-gray-600 dark:text-gray-300 mb-8">
          A simple and powerful template to get started with full-stack
          development using Next.js and FastAPI.
        </p>

        {/* Link to Dashboard */}
        <Link href="/dashboard">
          <Button className="px-8 py-4 text-xl font-semibold rounded-full shadow-lg bg-gradient-to-r from-blue-500 to-indigo-500 text-white hover:from-blue-600 hover:to-indigo-600 focus:ring-4 focus:ring-blue-300">
            Go to Dashboard
          </Button>
        </Link>

        {/* GitHub Badge */}
        <div className="mt-6">
          <Badge
            variant="outline"
            className="text-sm flex items-center gap-2 px-3 py-2 rounded-lg border-gray-300 dark:border-gray-700"
          >
            <FaGithub className="w-5 h-5 text-black dark:text-white" />
            <Link
              href="https://github.com/vintasoftware/nextjs-fastapi-template"
              target="_blank"
              className="hover:underline"
            >
              View on GitHub
            </Link>
          </Badge>
        </div>
      </div>
    </main>
  );
}



================================================
FILE: nextjs-frontend/app/dashboard/deleteButton.tsx
================================================
"use client";

import { removeItem } from "@/components/actions/items-action";
import { DropdownMenuItem } from "@/components/ui/dropdown-menu";

interface DeleteButtonProps {
  itemId: string;
}

export function DeleteButton({ itemId }: DeleteButtonProps) {
  const handleDelete = async () => {
    await removeItem(itemId);
  };

  return (
    <DropdownMenuItem
      className="text-red-500 cursor-pointer"
      onClick={handleDelete}
    >
      Delete
    </DropdownMenuItem>
  );
}



================================================
FILE: nextjs-frontend/app/dashboard/layout.tsx
================================================
import Link from "next/link";
import { Home, Users2, List } from "lucide-react";
import Image from "next/image";

import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { logout } from "@/components/actions/logout-action";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex min-h-screen">
      <aside className="fixed inset-y-0 left-0 z-10 w-16 flex flex-col border-r bg-background p-4">
        <div className="flex flex-col items-center gap-8">
          <Link
            href="/"
            className="flex items-center justify-center rounded-full"
          >
            <Image
              src="/images/vinta.png"
              alt="Vinta"
              width={64}
              height={64}
              className="object-cover transition-transform duration-200 hover:scale-105"
            />
          </Link>
          <Link
            href="/dashboard"
            className="flex items-center gap-2 text-muted-foreground hover:text-foreground"
          >
            <List className="h-5 w-5" />
          </Link>
          <Link
            href="/customers"
            className="flex items-center gap-2 text-muted-foreground hover:text-foreground"
          >
            <Users2 className="h-5 w-5" />
          </Link>
        </div>
      </aside>
      <main className="ml-16 w-full p-8 bg-muted/40">
        <header className="flex justify-between items-center mb-6">
          <Breadcrumb>
            <BreadcrumbList>
              <BreadcrumbItem>
                <BreadcrumbLink asChild>
                  <Link href="/" className="flex items-center gap-2">
                    <Home className="h-4 w-4" />
                    <span>Home</span>
                  </Link>
                </BreadcrumbLink>
              </BreadcrumbItem>
              <BreadcrumbSeparator>/</BreadcrumbSeparator>
              <BreadcrumbItem>
                <BreadcrumbLink asChild>
                  <Link href="/dashboard" className="flex items-center gap-2">
                    <List className="h-4 w-4" />
                    <span>Dashboard</span>
                  </Link>
                </BreadcrumbLink>
              </BreadcrumbItem>
            </BreadcrumbList>
          </Breadcrumb>
          <div className="relative">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <button className="flex items-center justify-center w-10 h-10 rounded-full bg-gray-300 hover:bg-gray-400">
                  <Avatar>
                    <AvatarFallback>U</AvatarFallback>
                  </Avatar>
                </button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" side="bottom">
                <DropdownMenuItem>
                  <Link
                    href="/support"
                    className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                  >
                    Support
                  </Link>
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <button
                    onClick={logout}
                    className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                  >
                    Logout
                  </button>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </header>
        <section className="grid gap-6">{children}</section>
      </main>
    </div>
  );
}



================================================
FILE: nextjs-frontend/app/dashboard/page.tsx
================================================
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  TableHeader,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
} from "@/components/ui/dropdown-menu";
import { fetchItems } from "@/components/actions/items-action";
import { DeleteButton } from "./deleteButton";
import { ReadItemResponse } from "@/app/openapi-client";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { PageSizeSelector } from "@/components/page-size-selector";
import { PagePagination } from "@/components/page-pagination";

interface DashboardPageProps {
  searchParams: Promise<{
    page?: string;
    size?: string;
  }>;
}

export default async function DashboardPage({
  searchParams,
}: DashboardPageProps) {
  const params = await searchParams;
  const page = Number(params.page) || 1;
  const size = Number(params.size) || 10;

  const items = (await fetchItems(page, size)) as ReadItemResponse;
  const totalPages = Math.ceil((items.total || 0) / size);

  return (
    <div>
      <h2 className="text-2xl font-semibold mb-6">Welcome to your Dashboard</h2>
      <p className="text-lg mb-6">
        Here, you can see the overview of your items and manage them.
      </p>

      <div className="mb-6">
        <Link href="/dashboard/add-item">
          <Button variant="outline" className="text-lg px-4 py-2">
            Add New Item
          </Button>
        </Link>
      </div>

      <section className="p-6 bg-white rounded-lg shadow-lg mt-8">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-semibold">Items</h2>
          <PageSizeSelector currentSize={size} />
        </div>

        <Table className="min-w-full text-sm">
          <TableHeader>
            <TableRow>
              <TableHead className="w-[120px]">Name</TableHead>
              <TableHead>Description</TableHead>
              <TableHead className="text-center">Quantity</TableHead>
              <TableHead className="text-center">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {!items.items?.length ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center">
                  No results.
                </TableCell>
              </TableRow>
            ) : (
              items.items.map((item, index) => (
                <TableRow key={index}>
                  <TableCell>{item.name}</TableCell>
                  <TableCell>{item.description}</TableCell>
                  <TableCell className="text-center">{item.quantity}</TableCell>
                  <TableCell className="text-center">
                    <DropdownMenu>
                      <DropdownMenuTrigger className="cursor-pointer p-1 text-gray-600 hover:text-gray-800">
                        <span className="text-lg font-semibold">...</span>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent className="p-2">
                        <DropdownMenuItem disabled={true}>
                          Edit
                        </DropdownMenuItem>
                        <DeleteButton itemId={item.id} />
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>

        {/* Pagination Controls */}
        <PagePagination
          currentPage={page}
          totalPages={totalPages}
          pageSize={size}
          totalItems={items.total || 0}
          basePath="/dashboard"
        />
      </section>
    </div>
  );
}



================================================
FILE: nextjs-frontend/app/dashboard/add-item/page.tsx
================================================
"use client";

import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { addItem } from "@/components/actions/items-action";
import { useActionState } from "react";
import { SubmitButton } from "@/components/ui/submitButton";

const initialState = { message: "" };

export default function CreateItemPage() {
  const [state, dispatch] = useActionState(addItem, initialState);

  return (
    <div className="bg-gray-50 dark:bg-gray-900 min-h-screen">
      <div className="max-w-4xl mx-auto p-6">
        <header className="mb-6">
          <h1 className="text-3xl font-semibold text-gray-800 dark:text-white">
            Create New Item
          </h1>
          <p className="text-lg text-gray-600 dark:text-gray-400">
            Enter the details of the new item below.
          </p>
        </header>

        <form
          action={dispatch}
          className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8 space-y-6"
        >
          <div className="space-y-6">
            <div className="space-y-3">
              <Label
                htmlFor="name"
                className="text-gray-700 dark:text-gray-300"
              >
                Item Name
              </Label>
              <Input
                id="name"
                name="name"
                type="text"
                placeholder="Item name"
                required
                className="w-full border-gray-300 dark:border-gray-600"
              />
              {state.errors?.name && (
                <p className="text-red-500 text-sm">{state.errors.name}</p>
              )}
            </div>

            <div className="space-y-3">
              <Label
                htmlFor="description"
                className="text-gray-700 dark:text-gray-300"
              >
                Item Description
              </Label>
              <Input
                id="description"
                name="description"
                type="text"
                placeholder="Description of the item"
                required
                className="w-full border-gray-300 dark:border-gray-600"
              />
              {state.errors?.description && (
                <p className="text-red-500 text-sm">
                  {state.errors.description}
                </p>
              )}
            </div>

            <div className="space-y-3">
              <Label
                htmlFor="quantity"
                className="text-gray-700 dark:text-gray-300"
              >
                Quantity
              </Label>
              <Input
                id="quantity"
                name="quantity"
                type="number"
                placeholder="Quantity"
                required
                className="w-full border-gray-300 dark:border-gray-600"
              />
              {state.errors?.quantity && (
                <p className="text-red-500 text-sm">{state.errors.quantity}</p>
              )}
            </div>
          </div>

          <SubmitButton text="Create Item" />

          {state?.message && (
            <div className="mt-2 text-center text-sm text-red-500">
              <p>{state.message}</p>
            </div>
          )}
        </form>
      </div>
    </div>
  );
}



================================================
FILE: nextjs-frontend/app/login/page.tsx
================================================
"use client";

import Link from "next/link";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

import { login } from "@/components/actions/login-action";
import { useActionState } from "react";
import { SubmitButton } from "@/components/ui/submitButton";
import { FieldError, FormError } from "@/components/ui/FormError";

export default function Page() {
  const [state, dispatch] = useActionState(login, undefined);
  return (
    <div className="flex h-screen w-full items-center justify-center bg-gray-50 dark:bg-gray-900 px-4">
      <form action={dispatch}>
        <Card className="w-full max-w-sm rounded-lg shadow-lg border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl font-semibold text-gray-800 dark:text-white">
              Login
            </CardTitle>
            <CardDescription className="text-sm text-gray-600 dark:text-gray-400">
              Enter your email below to log in to your account.
            </CardDescription>
          </CardHeader>
          <CardContent className="grid gap-6 p-6">
            <div className="grid gap-3">
              <Label
                htmlFor="username"
                className="text-gray-700 dark:text-gray-300"
              >
                Username
              </Label>
              <Input
                id="username"
                name="username"
                type="email"
                placeholder="m@example.com"
                required
                className="border-gray-300 dark:border-gray-600"
              />
              <FieldError state={state} field="username" />
            </div>
            <div className="grid gap-3">
              <Label
                htmlFor="password"
                className="text-gray-700 dark:text-gray-300"
              >
                Password
              </Label>
              <Input
                id="password"
                name="password"
                type="password"
                required
                className="border-gray-300 dark:border-gray-600"
              />
              <FieldError state={state} field="password" />
              <Link
                href="/password-recovery"
                className="ml-auto inline-block text-sm text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-500"
              >
                Forgot your password?
              </Link>
            </div>
            <SubmitButton text="Sign In" />
            <FormError state={state} />
            <div className="mt-4 text-center text-sm text-gray-600 dark:text-gray-400">
              Don&apos;t have an account?{" "}
              <Link
                href="/register"
                className="text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-500"
              >
                Sign up
              </Link>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}



================================================
FILE: nextjs-frontend/app/openapi-client/index.ts
================================================
// This file is auto-generated by @hey-api/openapi-ts
export * from "./sdk.gen";
export * from "./types.gen";



================================================
FILE: nextjs-frontend/app/openapi-client/sdk.gen.ts
================================================
// This file is auto-generated by @hey-api/openapi-ts

import {
  createClient,
  createConfig,
  type OptionsLegacyParser,
  urlSearchParamsBodySerializer,
} from "@hey-api/client-axios";
import type {
  AuthJwtLoginData,
  AuthJwtLoginError,
  AuthJwtLoginResponse,
  AuthJwtLogoutError,
  AuthJwtLogoutResponse,
  RegisterRegisterData,
  RegisterRegisterError,
  RegisterRegisterResponse,
  ResetForgotPasswordData,
  ResetForgotPasswordError,
  ResetForgotPasswordResponse,
  ResetResetPasswordData,
  ResetResetPasswordError,
  ResetResetPasswordResponse,
  VerifyRequestTokenData,
  VerifyRequestTokenError,
  VerifyRequestTokenResponse,
  VerifyVerifyData,
  VerifyVerifyError,
  VerifyVerifyResponse,
  UsersCurrentUserError,
  UsersCurrentUserResponse,
  UsersPatchCurrentUserData,
  UsersPatchCurrentUserError,
  UsersPatchCurrentUserResponse,
  UsersUserData,
  UsersUserError,
  UsersUserResponse,
  UsersPatchUserData,
  UsersPatchUserError,
  UsersPatchUserResponse,
  UsersDeleteUserData,
  UsersDeleteUserError,
  UsersDeleteUserResponse,
  ReadItemData,
  ReadItemError,
  ReadItemResponse,
  CreateItemData,
  CreateItemError,
  CreateItemResponse,
  DeleteItemData,
  DeleteItemError,
  DeleteItemResponse,
} from "./types.gen";

export const client = createClient(createConfig());

/**
 * Auth:Jwt.Login
 */
export const authJwtLogin = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<AuthJwtLoginData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    AuthJwtLoginResponse,
    AuthJwtLoginError,
    ThrowOnError
  >({
    ...options,
    ...urlSearchParamsBodySerializer,
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      ...options?.headers,
    },
    url: "/auth/jwt/login",
  });
};

/**
 * Auth:Jwt.Logout
 */
export const authJwtLogout = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<unknown, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    AuthJwtLogoutResponse,
    AuthJwtLogoutError,
    ThrowOnError
  >({
    ...options,
    url: "/auth/jwt/logout",
  });
};

/**
 * Register:Register
 */
export const registerRegister = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<RegisterRegisterData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    RegisterRegisterResponse,
    RegisterRegisterError,
    ThrowOnError
  >({
    ...options,
    url: "/auth/register",
  });
};

/**
 * Reset:Forgot Password
 */
export const resetForgotPassword = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<ResetForgotPasswordData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ResetForgotPasswordResponse,
    ResetForgotPasswordError,
    ThrowOnError
  >({
    ...options,
    url: "/auth/forgot-password",
  });
};

/**
 * Reset:Reset Password
 */
export const resetResetPassword = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<ResetResetPasswordData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    ResetResetPasswordResponse,
    ResetResetPasswordError,
    ThrowOnError
  >({
    ...options,
    url: "/auth/reset-password",
  });
};

/**
 * Verify:Request-Token
 */
export const verifyRequestToken = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<VerifyRequestTokenData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    VerifyRequestTokenResponse,
    VerifyRequestTokenError,
    ThrowOnError
  >({
    ...options,
    url: "/auth/request-verify-token",
  });
};

/**
 * Verify:Verify
 */
export const verifyVerify = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<VerifyVerifyData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    VerifyVerifyResponse,
    VerifyVerifyError,
    ThrowOnError
  >({
    ...options,
    url: "/auth/verify",
  });
};

/**
 * Users:Current User
 */
export const usersCurrentUser = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<unknown, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    UsersCurrentUserResponse,
    UsersCurrentUserError,
    ThrowOnError
  >({
    ...options,
    url: "/users/me",
  });
};

/**
 * Users:Patch Current User
 */
export const usersPatchCurrentUser = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UsersPatchCurrentUserData, ThrowOnError>,
) => {
  return (options?.client ?? client).patch<
    UsersPatchCurrentUserResponse,
    UsersPatchCurrentUserError,
    ThrowOnError
  >({
    ...options,
    url: "/users/me",
  });
};

/**
 * Users:User
 */
export const usersUser = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UsersUserData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    UsersUserResponse,
    UsersUserError,
    ThrowOnError
  >({
    ...options,
    url: "/users/{id}",
  });
};

/**
 * Users:Patch User
 */
export const usersPatchUser = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UsersPatchUserData, ThrowOnError>,
) => {
  return (options?.client ?? client).patch<
    UsersPatchUserResponse,
    UsersPatchUserError,
    ThrowOnError
  >({
    ...options,
    url: "/users/{id}",
  });
};

/**
 * Users:Delete User
 */
export const usersDeleteUser = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<UsersDeleteUserData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    UsersDeleteUserResponse,
    UsersDeleteUserError,
    ThrowOnError
  >({
    ...options,
    url: "/users/{id}",
  });
};

/**
 * Read Item
 */
export const readItem = <ThrowOnError extends boolean = false>(
  options?: OptionsLegacyParser<ReadItemData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    ReadItemResponse,
    ReadItemError,
    ThrowOnError
  >({
    ...options,
    url: "/items/",
  });
};

/**
 * Create Item
 */
export const createItem = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<CreateItemData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    CreateItemResponse,
    CreateItemError,
    ThrowOnError
  >({
    ...options,
    url: "/items/",
  });
};

/**
 * Delete Item
 */
export const deleteItem = <ThrowOnError extends boolean = false>(
  options: OptionsLegacyParser<DeleteItemData, ThrowOnError>,
) => {
  return (options?.client ?? client).delete<
    DeleteItemResponse,
    DeleteItemError,
    ThrowOnError
  >({
    ...options,
    url: "/items/{item_id}",
  });
};



================================================
FILE: nextjs-frontend/app/openapi-client/types.gen.ts
================================================
// This file is auto-generated by @hey-api/openapi-ts

export type BearerResponse = {
  access_token: string;
  token_type: string;
};

export type Body_auth_reset_forgot_password = {
  email: string;
};

export type Body_auth_reset_reset_password = {
  token: string;
  password: string;
};

export type Body_auth_verify_request_token = {
  email: string;
};

export type Body_auth_verify_verify = {
  token: string;
};

export type ErrorModel = {
  detail:
    | string
    | {
        [key: string]: string;
      };
};

export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};

export type ItemCreate = {
  name: string;
  description?: string | null;
  quantity?: number | null;
};

export type ItemRead = {
  name: string;
  description?: string | null;
  quantity?: number | null;
  id: string;
  user_id: string;
};

export type login = {
  grant_type?: string | null;
  username: string;
  password: string;
  scope?: string;
  client_id?: string | null;
  client_secret?: string | null;
};

export type Page_ItemRead_ = {
  items: Array<ItemRead>;
  total?: number | null;
  page: number | null;
  size: number | null;
  pages?: number | null;
};

export type UserCreate = {
  email: string;
  password: string;
  is_active?: boolean | null;
  is_superuser?: boolean | null;
  is_verified?: boolean | null;
};

export type UserRead = {
  id: string;
  email: string;
  is_active?: boolean;
  is_superuser?: boolean;
  is_verified?: boolean;
};

export type UserUpdate = {
  password?: string | null;
  email?: string | null;
  is_active?: boolean | null;
  is_superuser?: boolean | null;
  is_verified?: boolean | null;
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type AuthJwtLoginData = {
  body: login;
};

export type AuthJwtLoginResponse = BearerResponse;

export type AuthJwtLoginError = ErrorModel | HTTPValidationError;

export type AuthJwtLogoutResponse = unknown;

export type AuthJwtLogoutError = unknown;

export type RegisterRegisterData = {
  body: UserCreate;
};

export type RegisterRegisterResponse = UserRead;

export type RegisterRegisterError = ErrorModel | HTTPValidationError;

export type ResetForgotPasswordData = {
  body: Body_auth_reset_forgot_password;
};

export type ResetForgotPasswordResponse = unknown;

export type ResetForgotPasswordError = HTTPValidationError;

export type ResetResetPasswordData = {
  body: Body_auth_reset_reset_password;
};

export type ResetResetPasswordResponse = unknown;

export type ResetResetPasswordError = ErrorModel | HTTPValidationError;

export type VerifyRequestTokenData = {
  body: Body_auth_verify_request_token;
};

export type VerifyRequestTokenResponse = unknown;

export type VerifyRequestTokenError = HTTPValidationError;

export type VerifyVerifyData = {
  body: Body_auth_verify_verify;
};

export type VerifyVerifyResponse = UserRead;

export type VerifyVerifyError = ErrorModel | HTTPValidationError;

export type UsersCurrentUserResponse = UserRead;

export type UsersCurrentUserError = unknown;

export type UsersPatchCurrentUserData = {
  body: UserUpdate;
};

export type UsersPatchCurrentUserResponse = UserRead;

export type UsersPatchCurrentUserError =
  | ErrorModel
  | unknown
  | HTTPValidationError;

export type UsersUserData = {
  path: {
    id: string;
  };
};

export type UsersUserResponse = UserRead;

export type UsersUserError = unknown | HTTPValidationError;

export type UsersPatchUserData = {
  body: UserUpdate;
  path: {
    id: string;
  };
};

export type UsersPatchUserResponse = UserRead;

export type UsersPatchUserError = ErrorModel | unknown | HTTPValidationError;

export type UsersDeleteUserData = {
  path: {
    id: string;
  };
};

export type UsersDeleteUserResponse = void;

export type UsersDeleteUserError = unknown | HTTPValidationError;

export type ReadItemData = {
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
};

export type ReadItemResponse = Page_ItemRead_;

export type ReadItemError = HTTPValidationError;

export type CreateItemData = {
  body: ItemCreate;
};

export type CreateItemResponse = ItemRead;

export type CreateItemError = HTTPValidationError;

export type DeleteItemData = {
  path: {
    item_id: string;
  };
};

export type DeleteItemResponse = unknown;

export type DeleteItemError = HTTPValidationError;



================================================
FILE: nextjs-frontend/app/password-recovery/page.tsx
================================================
"use client";

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

import { passwordReset } from "@/components/actions/password-reset-action";
import { useActionState } from "react";
import { SubmitButton } from "@/components/ui/submitButton";
import Link from "next/link";
import { FormError } from "@/components/ui/FormError";

export default function Page() {
  const [state, dispatch] = useActionState(passwordReset, undefined);

  return (
    <div className="flex h-screen w-full items-center justify-center bg-gray-50 dark:bg-gray-900 px-4">
      <form action={dispatch}>
        <Card className="w-full max-w-sm rounded-lg shadow-lg border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl font-semibold text-gray-800 dark:text-white">
              Password Recovery
            </CardTitle>
            <CardDescription className="text-sm text-gray-600 dark:text-gray-400">
              Enter your email to receive instructions to reset your password.
            </CardDescription>
          </CardHeader>
          <CardContent className="grid gap-6 p-6">
            <div className="grid gap-3">
              <Label
                htmlFor="email"
                className="text-gray-700 dark:text-gray-300"
              >
                Email
              </Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="m@example.com"
                required
                className="border-gray-300 dark:border-gray-600"
              />
            </div>
            <SubmitButton text="Send" />
            <FormError state={state} />
            <div className="mt-2 text-sm text-center text-blue-500">
              {state?.message && <p>{state.message}</p>}
            </div>
            <div className="mt-4 text-center text-sm text-gray-600 dark:text-gray-400">
              <Link
                href="/login"
                className="text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-500"
              >
                Back to login
              </Link>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}



================================================
FILE: nextjs-frontend/app/password-recovery/confirm/page.tsx
================================================
"use client";

import { useActionState } from "react";
import { notFound, useSearchParams } from "next/navigation";
import { passwordResetConfirm } from "@/components/actions/password-reset-action";
import { SubmitButton } from "@/components/ui/submitButton";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Suspense } from "react";
import { FieldError, FormError } from "@/components/ui/FormError";

function ResetPasswordForm() {
  const [state, dispatch] = useActionState(passwordResetConfirm, undefined);
  const searchParams = useSearchParams();
  const token = searchParams.get("token");

  if (!token) {
    notFound();
  }

  return (
    <form action={dispatch}>
      <Card className="w-full max-w-sm">
        <CardHeader>
          <CardTitle className="text-2xl">Reset your Password</CardTitle>
          <CardDescription>
            Enter the new password and confirm it.
          </CardDescription>
        </CardHeader>
        <CardContent className="grid gap-4">
          <div className="grid gap-2">
            <Label htmlFor="password">Password</Label>
            <Input id="password" name="password" type="password" required />
          </div>
          <FieldError state={state} field="password" />
          <div className="grid gap-2">
            <Label htmlFor="passwordConfirm">Password Confirm</Label>
            <Input
              id="passwordConfirm"
              name="passwordConfirm"
              type="password"
              required
            />
          </div>
          <FieldError state={state} field="passwordConfirm" />
          <input
            type="hidden"
            id="resetToken"
            name="resetToken"
            value={token}
            readOnly
          />
          <SubmitButton text={"Send"} />
          <FormError state={state} />
        </CardContent>
      </Card>
    </form>
  );
}

export default function Page() {
  return (
    <div className="flex h-screen w-full items-center justify-center px-4">
      <Suspense fallback={<div>Loading reset form...</div>}>
        <ResetPasswordForm />
      </Suspense>
    </div>
  );
}



================================================
FILE: nextjs-frontend/app/register/page.tsx
================================================
"use client";

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

import { register } from "@/components/actions/register-action";
import { useActionState } from "react";
import { SubmitButton } from "@/components/ui/submitButton";
import Link from "next/link";
import { FieldError, FormError } from "@/components/ui/FormError";

export default function Page() {
  const [state, dispatch] = useActionState(register, undefined);
  return (
    <div className="flex h-screen w-full items-center justify-center bg-gray-50 dark:bg-gray-900 px-4">
      <form action={dispatch}>
        <Card className="w-full max-w-sm rounded-lg shadow-lg border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl font-semibold text-gray-800 dark:text-white">
              Sign Up
            </CardTitle>
            <CardDescription className="text-sm text-gray-600 dark:text-gray-400">
              Enter your email and password below to create your account.
            </CardDescription>
          </CardHeader>
          <CardContent className="grid gap-6 p-6">
            <div className="grid gap-3">
              <Label
                htmlFor="email"
                className="text-gray-700 dark:text-gray-300"
              >
                Email
              </Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="m@example.com"
                required
                className="border-gray-300 dark:border-gray-600"
              />
              <FieldError state={state} field="email" />
            </div>
            <div className="grid gap-3">
              <Label
                htmlFor="password"
                className="text-gray-700 dark:text-gray-300"
              >
                Password
              </Label>
              <Input
                id="password"
                name="password"
                type="password"
                required
                className="border-gray-300 dark:border-gray-600"
              />
              <FieldError state={state} field="password" />
            </div>
            <SubmitButton text="Sign Up" />
            <FormError state={state} />
            <div className="mt-4 text-center text-sm text-gray-600 dark:text-gray-400">
              <Link
                href="/login"
                className="text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-500"
              >
                Back to login
              </Link>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}



================================================
FILE: nextjs-frontend/components/page-pagination.tsx
================================================
import { Button } from "@/components/ui/button";
import Link from "next/link";
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  DoubleArrowLeftIcon,
  DoubleArrowRightIcon,
} from "@radix-ui/react-icons";

interface PagePaginationProps {
  currentPage: number;
  totalPages: number;
  pageSize: number;
  totalItems: number;
  basePath?: string;
}

export function PagePagination({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  basePath = "/dashboard",
}: PagePaginationProps) {
  const hasNextPage = currentPage < totalPages;
  const hasPreviousPage = currentPage > 1;

  const buildUrl = (page: number) =>
    `${basePath}?page=${page}&size=${pageSize}`;

  return (
    <div className="flex items-center justify-between my-4">
      <div className="text-sm text-gray-600">
        {totalItems === 0 ? (
          <>Showing 0 of 0 results</>
        ) : (
          <>
            Showing {(currentPage - 1) * pageSize + 1} to{" "}
            {Math.min(currentPage * pageSize, totalItems)} of {totalItems}{" "}
            results
          </>
        )}
      </div>

      <div className="flex items-center space-x-2">
        {/* First Page */}
        <Link
          href={buildUrl(1)}
          className={!hasPreviousPage ? "pointer-events-none opacity-50" : ""}
        >
          <Button variant="outline" size="sm" disabled={!hasPreviousPage}>
            <DoubleArrowLeftIcon className="h-4 w-4" />
          </Button>
        </Link>

        {/* Previous Page */}
        <Link
          href={buildUrl(currentPage - 1)}
          className={!hasPreviousPage ? "pointer-events-none opacity-50" : ""}
        >
          <Button variant="outline" size="sm" disabled={!hasPreviousPage}>
            <ChevronLeftIcon className="h-4 w-4" />
          </Button>
        </Link>

        {/* Page Info */}
        {totalPages > 0 && (
          <span className="text-sm font-medium">
            Page {currentPage} of {totalPages}
          </span>
        )}

        {/* Next Page */}
        <Link
          href={buildUrl(currentPage + 1)}
          className={hasNextPage ? "" : "pointer-events-none opacity-50"}
        >
          <Button variant="outline" size="sm" disabled={!hasNextPage}>
            <ChevronRightIcon className="h-4 w-4" />
          </Button>
        </Link>

        {/* Last Page */}
        <Link
          href={buildUrl(totalPages)}
          className={hasNextPage ? "" : "pointer-events-none opacity-50"}
        >
          <Button variant="outline" size="sm" disabled={!hasNextPage}>
            <DoubleArrowRightIcon className="h-4 w-4" />
          </Button>
        </Link>
      </div>
    </div>
  );
}



================================================
FILE: nextjs-frontend/components/page-size-selector.tsx
================================================
"use client";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useRouter } from "next/navigation";

interface PageSizeSelectorProps {
  currentSize: number;
}

export function PageSizeSelector({ currentSize }: PageSizeSelectorProps) {
  const router = useRouter();
  const pageSizeOptions = [5, 10, 20, 50, 100];

  const handleSizeChange = (newSize: string) => {
    router.push(`/dashboard?page=1&size=${newSize}`);
  };

  return (
    <div className="flex items-center space-x-2">
      <span className="text-sm text-gray-600">Items per page:</span>
      <Select value={currentSize.toString()} onValueChange={handleSizeChange}>
        <SelectTrigger className="w-20">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {pageSizeOptions.map((option) => (
            <SelectItem key={option} value={option.toString()}>
              {option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}



================================================
FILE: nextjs-frontend/components/actions/items-action.ts
================================================
"use server";

import { cookies } from "next/headers";
import { readItem, deleteItem, createItem } from "@/app/clientService";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { itemSchema } from "@/lib/definitions";

export async function fetchItems(page: number = 1, size: number = 10) {
  const cookieStore = await cookies();
  const token = cookieStore.get("accessToken")?.value;

  if (!token) {
    return { message: "No access token found" };
  }

  const { data, error } = await readItem({
    query: {
      page: page,
      size: size,
    },
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (error) {
    return { message: error };
  }

  return data;
}

export async function removeItem(id: string) {
  const cookieStore = await cookies();
  const token = cookieStore.get("accessToken")?.value;

  if (!token) {
    return { message: "No access token found" };
  }

  const { error } = await deleteItem({
    headers: {
      Authorization: `Bearer ${token}`,
    },
    path: {
      item_id: id,
    },
  });

  if (error) {
    return { message: error };
  }
  revalidatePath("/dashboard");
}

export async function addItem(prevState: {}, formData: FormData) {
  const cookieStore = await cookies();
  const token = cookieStore.get("accessToken")?.value;

  if (!token) {
    return { message: "No access token found" };
  }

  const validatedFields = itemSchema.safeParse({
    name: formData.get("name"),
    description: formData.get("description"),
    quantity: formData.get("quantity"),
  });

  if (!validatedFields.success) {
    return { errors: validatedFields.error.flatten().fieldErrors };
  }

  const { name, description, quantity } = validatedFields.data;

  const input = {
    headers: {
      Authorization: `Bearer ${token}`,
    },
    body: {
      name,
      description,
      quantity,
    },
  };
  const { error } = await createItem(input);
  if (error) {
    return { message: `${error.detail}` };
  }
  redirect(`/dashboard`);
}



================================================
FILE: nextjs-frontend/components/actions/login-action.ts
================================================
"use server";

import { cookies } from "next/headers";

import { authJwtLogin } from "@/app/clientService";
import { redirect } from "next/navigation";
import { loginSchema } from "@/lib/definitions";
import { getErrorMessage } from "@/lib/utils";

export async function login(prevState: unknown, formData: FormData) {
  const validatedFields = loginSchema.safeParse({
    username: formData.get("username") as string,
    password: formData.get("password") as string,
  });

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { username, password } = validatedFields.data;

  const input = {
    body: {
      username,
      password,
    },
  };

  try {
    const { data, error } = await authJwtLogin(input);
    if (error) {
      return { server_validation_error: getErrorMessage(error) };
    }
    (await cookies()).set("accessToken", data.access_token);
  } catch (err) {
    console.error("Login error:", err);
    return {
      server_error: "An unexpected error occurred. Please try again later.",
    };
  }
  redirect("/dashboard");
}



================================================
FILE: nextjs-frontend/components/actions/logout-action.ts
================================================
"use server";

import { cookies } from "next/headers";
import { authJwtLogout } from "@/app/clientService";
import { redirect } from "next/navigation";

export async function logout() {
  const cookieStore = await cookies();
  const token = cookieStore.get("accessToken")?.value;

  if (!token) {
    return { message: "No access token found" };
  }

  const { error } = await authJwtLogout({
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (error) {
    return { message: error };
  }

  cookieStore.delete("accessToken");
  redirect(`/login`);
}



================================================
FILE: nextjs-frontend/components/actions/password-reset-action.ts
================================================
"use server";

import { resetForgotPassword, resetResetPassword } from "@/app/clientService";
import { redirect } from "next/navigation";
import { passwordResetConfirmSchema } from "@/lib/definitions";
import { getErrorMessage } from "@/lib/utils";

export async function passwordReset(prevState: unknown, formData: FormData) {
  const input = {
    body: {
      email: formData.get("email") as string,
    },
  };

  try {
    const { error } = await resetForgotPassword(input);
    if (error) {
      return { server_validation_error: getErrorMessage(error) };
    }
    return { message: "Password reset instructions sent to your email." };
  } catch (err) {
    console.error("Password reset error:", err);
    return {
      server_error: "An unexpected error occurred. Please try again later.",
    };
  }
}

export async function passwordResetConfirm(
  prevState: unknown,
  formData: FormData,
) {
  const validatedFields = passwordResetConfirmSchema.safeParse({
    token: formData.get("resetToken") as string,
    password: formData.get("password") as string,
    passwordConfirm: formData.get("passwordConfirm") as string,
  });

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { token, password } = validatedFields.data;
  const input = {
    body: {
      token,
      password,
    },
  };
  try {
    const { error } = await resetResetPassword(input);
    if (error) {
      return { server_validation_error: getErrorMessage(error) };
    }
    redirect(`/login`);
  } catch (err) {
    console.error("Password reset confirmation error:", err);
    return {
      server_error: "An unexpected error occurred. Please try again later.",
    };
  }
}



================================================
FILE: nextjs-frontend/components/actions/register-action.ts
================================================
"use server";

import { redirect } from "next/navigation";

import { registerRegister } from "@/app/clientService";

import { registerSchema } from "@/lib/definitions";
import { getErrorMessage } from "@/lib/utils";

export async function register(prevState: unknown, formData: FormData) {
  const validatedFields = registerSchema.safeParse({
    email: formData.get("email") as string,
    password: formData.get("password") as string,
  });

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { email, password } = validatedFields.data;

  const input = {
    body: {
      email,
      password,
    },
  };
  try {
    const { error } = await registerRegister(input);
    if (error) {
      return { server_validation_error: getErrorMessage(error) };
    }
  } catch (err) {
    console.error("Registration error:", err);
    return {
      server_error: "An unexpected error occurred. Please try again later.",
    };
  }
  redirect(`/login`);
}



================================================
FILE: nextjs-frontend/components/ui/avatar.tsx
================================================
"use client";

import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "@/lib/utils";

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className,
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className,
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };



================================================
FILE: nextjs-frontend/components/ui/badge.tsx
================================================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };



================================================
FILE: nextjs-frontend/components/ui/breadcrumb.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cn } from "@/lib/utils";
import { ChevronRightIcon, DotsHorizontalIcon } from "@radix-ui/react-icons";

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = "Breadcrumb";

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className,
    )}
    {...props}
  />
));
BreadcrumbList.displayName = "BreadcrumbList";

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
));
BreadcrumbItem.displayName = "BreadcrumbItem";

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = "BreadcrumbLink";

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
));
BreadcrumbPage.displayName = "BreadcrumbPage";

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRightIcon />}
  </li>
);
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <DotsHorizontalIcon className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};



================================================
FILE: nextjs-frontend/components/ui/button.tsx
================================================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };



================================================
FILE: nextjs-frontend/components/ui/card.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};



================================================
FILE: nextjs-frontend/components/ui/dropdown-menu.tsx
================================================
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { cn } from "@/lib/utils";
import {
  CheckIcon,
  ChevronRightIcon,
  DotFilledIcon,
} from "@radix-ui/react-icons";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};



================================================
FILE: nextjs-frontend/components/ui/form.tsx
================================================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};



================================================
FILE: nextjs-frontend/components/ui/FormError.tsx
================================================
interface ErrorState {
  errors?: {
    [key: string]: string | string[];
  };
  server_validation_error?: string;
  server_error?: string;
}

interface FormErrorProps {
  state?: ErrorState;
  className?: string;
}

export function FormError({ state, className = "" }: FormErrorProps) {
  if (!state) return null;

  const error = state.server_validation_error || state.server_error;
  if (!error) return null;

  return <p className={`text-sm text-red-500 ${className}`}>{error}</p>;
}

interface FieldErrorProps {
  state?: ErrorState;
  field: string;
  className?: string;
}

export function FieldError({ state, field, className = "" }: FieldErrorProps) {
  if (!state?.errors) return null;

  const error = state.errors[field];
  if (!error) return null;

  if (Array.isArray(error)) {
    return (
      <div className={`text-sm text-red-500 ${className}`}>
        <ul className="list-disc ml-4">
          {error.map((err) => (
            <li key={err}>{err}</li>
          ))}
        </ul>
      </div>
    );
  }

  return <p className={`text-sm text-red-500 ${className}`}>{error}</p>;
}



================================================
FILE: nextjs-frontend/components/ui/input.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };



================================================
FILE: nextjs-frontend/components/ui/label.tsx
================================================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };



================================================
FILE: nextjs-frontend/components/ui/select.tsx
================================================
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { cn } from "@/lib/utils";
import {
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@radix-ui/react-icons";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDownIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronUpIcon className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronDownIcon className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};



================================================
FILE: nextjs-frontend/components/ui/submitButton.tsx
================================================
import { useFormStatus } from "react-dom";
import { Button } from "@/components/ui/button";

export function SubmitButton({ text }: { text: string }) {
  const { pending } = useFormStatus();

  return (
    <Button className="w-full" type="submit" disabled={pending}>
      {pending ? "Loading..." : text}
    </Button>
  );
}



================================================
FILE: nextjs-frontend/components/ui/table.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className,
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className,
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className,
    )}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};



================================================
FILE: nextjs-frontend/components/ui/tabs.tsx
================================================
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };



================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->

## Screenshots (if appropriate):

## Steps to reproduce (if appropriate):

## Types of changes
<!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: -->
- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to change)

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] My change requires documentation updates.
- [ ] I have updated the documentation accordingly.
- [ ] My change requires dependencies updates.
- [ ] I have updated the dependencies accordingly.
